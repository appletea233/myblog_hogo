[{"content":"函数调用关系 结构体信息 Page 1 2 3 4 5 6 7 8 9  struct Page_list{ struct { struct { struct Page *le_next; struct Page le_prev; } pp_link; u_short pp_ref; }* lh_first; // Page* }    Env_list结构与之类似  Trapframe 1 2 3 4 5 6 7 8 9 10 11 12 13  struct Trapframe { //lr:need to be modified(reference to linux pt_regs) TODO \t/* Saved main processor registers. */ unsigned long regs[32]; /* Saved special registers. */ unsigned long cp0_status; unsigned long hi; unsigned long lo; unsigned long cp0_badvaddr; unsigned long cp0_cause; unsigned long cp0_epc; unsigned long pc; };   Env 1 2 3 4 5 6 7 8 9 10 11  struct Env { struct Trapframe env_tf; // Saved registers  LIST_ENTRY(Env) env_link; // Free LIST_ENTRY  u_int env_id; // Unique environment identifier  u_int env_parent_id; // env_id of this env\u0026#39;s parent  u_int env_status; // Status of the environment  Pde *env_pgdir; // Kernel virtual address of page dir  u_int env_cr3; LIST_ENTRY(Env) env_sched_link; u_int env_pri; };    env_status : 该变量只能有以下三种取值：   ENV_FREE : 表明该进程是不活动的，即该进程控制块处于进程空闲链表中。 ENV_NOT_RUNNABLE : 表明该进程处于阻塞状态，处于该状态的进程需要在一定条件下变成就绪状态从而被CPU调度。（比如因进程通信阻塞时变为 ENV_NOT_RUNNABLE，收到信息后变回 ENV_RUNNABLE） ENV_RUNNABLE : 表明该进程处于执行状态或就绪状态，即其可能是正在运行的，也可能正在等待被调度。  Ehdr与Phdr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  typedef struct { unsigned char\te_ident[EI_NIDENT];\t/* Magic number and other info */ Elf32_Half\te_type;\t/* Object file type */ Elf32_Half\te_machine;\t/* Architecture */ Elf32_Word\te_version;\t/* Object file version */ Elf32_Addr\te_entry;\t/* Entry point virtual address */ Elf32_Off\te_phoff;\t/* Program header table file offset */ Elf32_Off\te_shoff;\t/* Section header table file offset */ Elf32_Word\te_flags;\t/* Processor-specific flags */ Elf32_Half\te_ehsize;\t/* ELF header size in bytes */ Elf32_Half\te_phentsize;\t/* Program header table entry size */ Elf32_Half\te_phnum;\t/* Program header table entry count */ Elf32_Half\te_shentsize;\t/* Section header table entry size */ Elf32_Half\te_shnum;\t/* Section header table entry count */ Elf32_Half\te_shstrndx;\t/* Section header string table index */ } Elf32_Ehdr;   1 2 3 4 5 6 7 8 9 10  typedef struct { Elf32_Word\tp_type;\t/* Segment type */ Elf32_Off\tp_offset;\t/* Segment file offset */ Elf32_Addr\tp_vaddr;\t/* Segment virtual address */ Elf32_Addr\tp_paddr;\t/* Segment physical address */ Elf32_Word\tp_filesz;\t/* Segment size in file */ Elf32_Word\tp_memsz;\t/* Segment size in memory */ Elf32_Word\tp_flags;\t/* Segment flags */ Elf32_Word\tp_align;\t/* Segment alignment */ } Elf32_Phdr;   一些全局变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  // env.h ./include/env.h:11:#define LOG2NENV 10 ./include/env.h:12:#define NENV (1\u0026lt;\u0026lt;LOG2NENV) ./include/env.h:13:#define ENVX(envid) ((envid) \u0026amp; (NENV - 1)) // env.c struct Env *envs = NULL; // All environments struct Env *curenv = NULL; // the current env  static struct Env_list env_free_list; // Free list struct Env_list env_sched_list[2]; // Runnable list  extern Pde *boot_pgdir; extern char *KERNEL_SP; static u_int asid_bitmap[2] = {0}; // 64  // mmu.c ./include/error.h:8:#define E_BAD_ENV 2 // Environment doesn\u0026#39;t exist or otherwise ./include/mmu.h:109:#define E_BAD_ENV 2 // Environment doesn\u0026#39;t exist or otherwise  // page相关 #define BY2PG\t4096\t// bytes to a page #define PDMAP\t(4*1024*1024)\t// bytes mapped by a page directory entry #define PGSHIFT\t12 #define PDSHIFT\t22\t// log2(PDMAP) #define PDX(va)\t((((u_long)(va))\u0026gt;\u0026gt;22) \u0026amp; 0x03FF) // 取页目录序号 #define PTX(va)\t((((u_long)(va))\u0026gt;\u0026gt;12) \u0026amp; 0x03FF) // 取...序号 #define PTE_ADDR(pte)\t((u_long)(pte)\u0026amp;~0xFFF)  // page number field of address #define PPN(va)\t(((u_long)(va))\u0026gt;\u0026gt;12) #define VPN(va)\tPPN(va)  #define VA2PFN(va)\t(((u_long)(va)) \u0026amp; 0xFFFFF000 ) // va 2 PFN for EntryLo0/1 #define PTE2PT\t1024  // 内存地图 #define KERNBASE 0x80010000  #define VPT (ULIM + PDMAP ) #define KSTACKTOP (VPT-0x100) #define KSTKSIZE (8*BY2PG) #define ULIM 0x80000000\t #define UVPT (ULIM - PDMAP) #define UPAGES (UVPT - PDMAP) #define UENVS (UPAGES - PDMAP) #define UTOP UENVS  #define UXSTACKTOP (UTOP) #define TIMESTACK 0x82000000  #define PTE_ADDR(pte) ((u_long)(pte)\u0026amp;~0xFFF)   0x00400000\n变量转换  page2ppn page2pa page2kva：将页转换为内核的虚拟地址 va2pa  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  LIST_HEAD(Page_list, Page); typedef LIST_ENTRY(Page) Page_LIST_entry_t; struct Page { Page_LIST_entry_t pp_link;\t/* free list link */ // Ref is the count of pointers (usually in page table entries) \t// to this page. This only holds for pages allocated using \t// page_alloc. Pages allocated at boot time using pmap.c\u0026#39;s \u0026#34;alloc\u0026#34; \t// do not have valid reference count fields.  u_short pp_ref; }; extern struct Page *pages; static inline u_long page2ppn(struct Page *pp) { return pp - pages; } static inline u_long page2pa(struct Page *pp) { return page2ppn(pp)\u0026lt;\u0026lt;PGSHIFT; } static inline struct Page * pa2page(u_long pa) { if (PPN(pa) \u0026gt;= npage) panic(\u0026#34;pa2page called with invalid pa: %x\u0026#34;, pa); return \u0026amp;pages[PPN(pa)]; } static inline u_long page2kva(struct Page *pp) { return KADDR(page2pa(pp)); } static inline u_long va2pa(Pde *pgdir, u_long va) { Pte *p; pgdir = \u0026amp;pgdir[PDX(va)]; if (!(*pgdir\u0026amp;PTE_V)) return ~0; p = (Pte*)KADDR(PTE_ADDR(*pgdir)); if (!(p[PTX(va)]\u0026amp;PTE_V)) return ~0; return PTE_ADDR(p[PTX(va)]); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #define ULIM 0x80000000 #define PADDR(kva)\t\\ ({\t\\ u_long a = (u_long) (kva);\t\\ if (a \u0026lt; ULIM)\t\\ panic(\u0026#34;PADDR called with invalid kva %08lx\u0026#34;, a);\\ a - ULIM;\t\\ })  // translates from physical address to kernel virtual address #define KADDR(pa)\t\\ ({\t\\ u_long ppn = PPN(pa);\t\\ if (ppn \u0026gt;= npage)\t\\ panic(\u0026#34;KADDR called with invalid pa %08lx\u0026#34;, (u_long)pa);\\ (pa) + ULIM;\t\\ })   Exercise exercise 3.1  使用boot_map_segment进行段映射，envs 数组应该被UENVS 区域映射  exercise 3.2  使用envs函数，注意queue.h函数调用的参数类型。 插入顺序为倒序  exercise 3.3 关于asid_alloc函数 asid_alloc 函数，这个函数的作用是为新创建的进程分配一个异于当前所有未被释放的进程的 ASID。\n  这个 ASID是什么？\n  为什么要与其他的进程不同呢？\n  根据 lab2 的学习我们得知进程是通过页表来访问内存的，而不同的进程的同一个虚拟地址可能会映射到不同的物理地址。\n为了实现这个功能，TLB 中除了存储页表的映射信息之外，还会存储进程的标识编号，作为 Key 的一部分，用于保证查到的页面映射属于当前进程，而这个编号就是ASID。显然，不同进程的虚拟地址是可以对应相同 VPN 的，而如果 ASID 也不具备唯一标识性，就与 TLB Field 的唯一性要求相矛盾了。因此，直到进程被销毁或 TLB 被清空时，才可以把这个 ASID 分配给其他进程。\n 为什么不能简单的通过自增来避免冲突呢？  简单的回答：用来存储ASID的位数有限，自增容易发生溢出\nexercise 3.4 env_setup_vm 1 2 3 4 5 6 7 8 9  static int env_setup_vm(struct Env *e); for (i = 0; i \u0026lt; PDX(UTOP); i++){ pgdir[i] = 0; } for (i = PDX(UTOP); i\u0026lt;PTE2PT; i++){ if (i != PDX(VPT) \u0026amp;\u0026amp; i != PDX(UVPT)) pgdir[i] = boot_pgdir[i]; }    很多疑问 关于boot_pgdir  exercise 3.5 env_alloc 1 2  // 设置sp寄存器 e-\u0026gt;env_tf.regs[29] = USTACKTOP;   exercise 3.6 load_icode_mapper\t 调用链：load_icode -\u0026gt; load_elf -\u0026gt; load_icode_mapper\nexercise 3.7 load_elf和load_icode exercise 3.8 env_create 和env_create_priority 调用链：env_create -\u0026gt; env_create_priority\nexercise 3.9 mips_init exercise 3.10 env_run exercise 3.11 page_init Thinking Thinking 3.1 思考envid2env 函数:\n为什么envid2env 中需要判断e-\u0026gt;env_id != envid 的情况？如果没有这步判断会发生什么情况？\n envid可能大于64 没有这一步可能导致非内存控制快的内存地址被转换  Thinking 3.2 结合include/mmu.h 中的地址空间布局，思考env_setup_vm 函数：\n UTOP 和ULIM 的含义分别是什么，UTOP 和ULIM 之间的区域与UTOP以下的区域相比有什么区别？   ULIM以上是内核态 UTOP与ULIM之间有三个页表 ULIM之下的是栈，UTOP和ULIM之间的区域是页表   请结合系统自映射机制解释代码中pgdir[PDX(UVPT)]=env_cr3的含义。  自身映射到自身\n 谈谈自己对进程中物理地址和虚拟地址的理解。  之间有映射关系。\nThinking 3.3 找到 user_data 这一参数的来源，思考它的作用。没有这个参数可不可以？为什么？（可以尝试说明实际的应用场景，举一个实际的库中的例子）\n 为load_icode_mapper传参  Thinking 3.4 结合load_icode_mapper 的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？\n va不与页对其 va+binsize不与页面对齐  Thinking 3.5 思考上面这一段话，并根据自己在lab2 中的理解，回答：\n 你认为这里的 env_tf.pc 存储的是物理地址还是虚拟地址?  是虚拟地址\n 你觉得entry_point其值对于每个进程是否一样？该如何理解这种统一或不同  不一定相同，对不同的elf文件entry_point不同。\nThinking 3.6 请查阅相关资料解释，上面提到的epc是什么？为什么要将env_tf.pc设置为epc呢？\nThinking 3.7 关于 TIMESTACK，请思考以下问题：\n 操作系统在何时将什么内容存到了 TIMESTACK 区域 TIMESTACK 和 env_asm.S 中所定义的 KERNEL_SP 的含义有何不同  Thinking 3.8 试找出上述 5 个异常处理函数的具体实现位置。\n   异常号 处理函数 含义 具体实现位置 备注     0 handle_int 表示中断，由时钟中断、控制台中断等中断造成 ./lib/genex.S    1 handle_mod 表示存储异常，进行存储操作时该页被标记为只读 ./lib/genex.S    2 handle_tlb TLB 异常，TLB 中没有和程序地址匹配的有效入口 ./lib/genex.S    3 handle_tlb TLB 异常，TLB 失效，且未处于异常模式（用于提高处理效率） ./lib/genex.S    8 handle_sys 系统调用，陷入内核，执行了 syscall 指令 ./lib/syscall.S     Thinking 3.9 阅读 kclock_asm.S 和 genex.S 两个文件，并尝试说出 set_timer 和timer_irq 函数中每行汇编代码的作用\nset_timer 1 2 3 4 5 6 7 8 9 10  LEAF(set_timer) li t0, 0xc8 sb t0, 0xb5000100\t// 向0xb5000100 位置写入0xc8 sw\tsp, KERNEL_SP\t// 将当前栈指针保存到KERNEL_SP setup_c0_status STATUS_CU0|0x1001 0\t// 调用setup_c0_status函数 jr ra nop END(set_timer)   time_irq 1 2 3 4 5 6 7 8 9 10 11 12 13  timer_irq: sb zero, 0xb5000110\t// 在0xb5000110写入0 1:\tj\tsched_yield\t// 跳转到sched_ yield nop /*li t1, 0xff lw t0, delay addu t0, 1 sw\tt0, delay beq\tt0,t1,1f\tnop*/ j\tret_from_exception\tnop   要产生时钟中断，我们不仅要了解中断的产生与处理，还要了解 gxemul 是如何模拟时钟中断的。kclock_init 函数完成了时钟的初始化，该函数主要调用 set_timer 函数，完成如下操作：\n 首先向0xb5000100 位置写入0xc8，其中0xb5000000 是模拟器(gxemul) 映射实时钟的位置。偏移量为0x100 表示来设置实时钟中断的频率，0xc8 则表示1 秒钟中断200次，如果写入0，表示关闭实时钟。实时钟对于R3000 来说绑定到了4 号中断上，故这段代码其实主要用来触发了4 号中断。注意这里的中断号和异常号是不一样的概念，我们实验的异常包括中断。 一旦实时钟中断产生，就会触发MIPS 中断，从而MIPS 将PC 指向0x80000080，从而跳转到.text.exc_vec3代码段执行。对于实时钟引起的中断，通过.text.exc_vec3代码段的分发，最终会调用handle_ int 函数来处理实时钟中断。 在handle_ int 判断CP0_CAUSE寄存器是不是对应的4 号中断位引发的中断，如果是，则执行中断服务函数timer_ irq。 在timer_ irq 里直接跳转到sched_ yield 中执行。而这个函数就是我们将要补充的调度函数。  SAVE_ALL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  .macro SAVE_ALL // 前四行其首先取出了 SR 寄存器的值, 然后利用移位等操作判断第 28 位的值, 根据前面的讲述我们可以知道, 也即判断当前是否处于用户模式下。5 mfc0\tk0,CP0_STATUS sll\tk0,3 /* extract cu0 bit */ bltz\tk0,1f nop /* * Called from user mode, new stack */ // lui\tk1,%hi(kernelsp) // lw\tk1,%lo(kernelsp)(k1) //not clear right now // 接下来将当前运行栈的地址保存到 k0 中；然后调用 get_sp 宏，根据中断异常的种类判断需要保存的位置，并分配一定的空间；将之前的运行栈地址与 2 号寄存器 $v0 先保存起来，便于后面可以放心的使用 sp 寄存器与 v0 寄存器。 1: move\tk0,sp get_sp move\tk1,sp subu\tsp,k1,TF_SIZE sw\tk0,TF_REG29(sp) sw\t$2,TF_REG2(sp) mfc0\tv0,CP0_STATUS sw\tv0,TF_STATUS(sp) mfc0\tv0,CP0_CAUSE sw\tv0,TF_CAUSE(sp) mfc0\tv0,CP0_EPC sw\tv0,TF_EPC(sp) mfc0\tv0, CP0_BADVADDR sw\tv0, TF_BADVADDR(sp) mfhi\tv0 sw\tv0,TF_HI(sp) mflo\tv0 sw\tv0,TF_LO(sp) sw\t$0,TF_REG0(sp) sw\t$1,TF_REG1(sp) //sw\t$2,TF_REG2(sp) sw\t$3,TF_REG3(sp) sw\t$4,TF_REG4(sp) sw\t$5,TF_REG5(sp) sw\t$6,TF_REG6(sp) sw\t$7,TF_REG7(sp) sw\t$8,TF_REG8(sp) sw\t$9,TF_REG9(sp) sw\t$10,TF_REG10(sp) sw\t$11,TF_REG11(sp) sw\t$12,TF_REG12(sp) sw\t$13,TF_REG13(sp) sw\t$14,TF_REG14(sp) sw\t$15,TF_REG15(sp) sw\t$16,TF_REG16(sp) sw\t$17,TF_REG17(sp) sw\t$18,TF_REG18(sp) sw\t$19,TF_REG19(sp) sw\t$20,TF_REG20(sp) sw\t$21,TF_REG21(sp) sw\t$22,TF_REG22(sp) sw\t$23,TF_REG23(sp) sw\t$24,TF_REG24(sp) sw\t$25,TF_REG25(sp) sw\t$26,TF_REG26(sp) sw\t$27,TF_REG27(sp) sw\t$28,TF_REG28(sp) sw\t$30,TF_REG30(sp) sw\t$31,TF_REG31(sp) .endm   内存地图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  /* o 4G -----------\u0026gt; +----------------------------+------------0x100000000 o | ... | kseg3 o +----------------------------+------------0xe000 0000 o | ... | kseg2 o +----------------------------+------------0xc000 0000 o | Interrupts \u0026amp; Exception | kseg1 o +----------------------------+------------0xa000 0000 o | Invalid memory | /|\\ o +----------------------------+----|-------Physics Memory Max o | ... | kseg0 o VPT,KSTACKTOP-----\u0026gt; +----------------------------+----|-------0x8040 0000-------end o | Kernel Stack | | KSTKSIZE /|\\ o +----------------------------+----|------ | o | Kernel Text | | PDMAP o KERNBASE -----\u0026gt; +----------------------------+----|-------0x8001 0000 | o | Interrupts \u0026amp; Exception | \\|/ \\|/ o ULIM -----\u0026gt; +----------------------------+------------0x8000 0000------- o | User VPT | PDMAP /|\\ o UVPT -----\u0026gt; +----------------------------+------------0x7fc0 0000 | o | PAGES | PDMAP | o UPAGES -----\u0026gt; +----------------------------+------------0x7f80 0000 | o | ENVS | PDMAP | o UTOP,UENVS -----\u0026gt; +----------------------------+------------0x7f40 0000 | o UXSTACKTOP -/ | user exception stack | BY2PG | o +----------------------------+------------0x7f3f f000 | o | Invalid memory | BY2PG | o USTACKTOP ----\u0026gt; +----------------------------+------------0x7f3f e000 | o | normal user stack | BY2PG | o +----------------------------+------------0x7f3f d000 | a | | | a ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | a . . | a . . kuseg a . . | a |~~~~~~~~~~~~~~~~~~~~~~~~~~~~| | a | | | o UTEXT -----\u0026gt; +----------------------------+ | o | | 2 * PDMAP \\|/ a 0 ------------\u0026gt; +----------------------------+ ----------------------------- o */    boot_pgdir 被映射到UPAGES envs被映射到UENVS  04000000\n异常与中断 我们实验里认为凡是引起控制流突变的都叫做异常，而中断仅仅是异常的一种，并且是仅有的一种异步异常。\n异常的产生与返回 ","permalink":"http://appletea233.github.io/myblog_hogo/posts/blog/%E6%96%87%E6%A1%A3/","summary":"函数调用关系 结构体信息 Page 1 2 3 4 5 6 7 8 9 struct Page_list{ struct { struct { struct Page *le_next; struct Page le_prev; } pp_link; u_short pp_ref; }* lh_first; // Page* } Env_list结构与之类似 Trapframe 1 2 3 4 5 6 7 8 9 10 11 12 13","title":"BUAA操作系统lab3笔记"},{"content":"hhhhh 我的第一篇博客\nhhhhhhh 1  printf(\u0026#34;hello world\u0026#34;);   ","permalink":"http://appletea233.github.io/myblog_hogo/posts/blog/my-first-post/","summary":"hhhhh 我的第一篇博客 hhhhhhh 1 printf(\u0026#34;hello world\u0026#34;);","title":"My First Post"},{"content":"","permalink":"http://appletea233.github.io/myblog_hogo/tags/","summary":"","title":"🔖标签"},{"content":"","permalink":"http://appletea233.github.io/myblog_hogo/about/","summary":"","title":"🙋🏻‍♂️关于"},{"content":" Appletea\u0026#39;s Blog 一个记录学习、生活的博客     Appletea\u0026#39;s Blog 一个记录学习、生活的博客    ","permalink":"http://appletea233.github.io/myblog_hogo/links/","summary":"Appletea\u0026#39;s Blog 一个记录学习、生活的博客 Appletea\u0026#39;s Blog 一个记录学习、生活的博客","title":"🤝友链"}]