[{"content":"åŸºç¡€çŸ¥è¯† å¯„å­˜å™¨ åŸºç¡€æ“ä½œ ç³»ç»Ÿè°ƒç”¨ GCDæœ€å¤§å…¬çº¦æ•°  ä¸»è¦è€ƒå¯Ÿå¾ªç¯ï¼Œä½¿ç”¨$j$æŒ‡ä»¤è¿›è¡Œä»£ç å—é—´çš„è·³è½¬  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  .data .text # è¯»å…¥æ•°æ® li $v0 5 syscall addi $t0, $v0, 0 li $v0 5 syscall addi $t1, $v0, 0 # å¾ªç¯æ±‚å…¬çº¦æ•° while: beqz $t1, next div $t0, $t1 move $t0, $t1 mfhi $s0 addi $t1, $s0, 0 j while next: addi $a0, $t0, 0 li $v0, 1 syscall li $v0, 10 syscall   çº¦ç‘Ÿå¤«é—®é¢˜ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  .data v: .word 1:110 .text main: li $v0, 5 syscall move $s0, $v0 # å­˜å‚¨n li $v0, 5 syscall move $s1, $v0 # å­˜å‚¨m li $v0, 5 syscall move $s2, $v0 # å­˜å‚¨k addi $t0, $s0, 0 # å½“å‰äººæ•°alive addi $t1, $s2, 0 # å½“å‰è½®åˆ°çš„äººindex move $t2, $0 #å½“å‰è½®æ¬¡è½®åˆ°è¿‡çš„äººæ•°num while1: beq $t0, 0, out1 mul $t3, $t1, 4 lw $t4, v($t3) add $t2, $t2, $t4 bne $t2, $s1, L sw $0, v($t3) addi $t0, $t0, -1 move $t2, $0 addi $a0, $t1, 1 li $v0, 1 syscall L: addi $t1, $t1, 1 bne $t1, $s0, L2 move $t1, $0 L2: j while1 out1: li $v0, 10 syscall   æ–æ³¢é‚£å¥‘æ•°åˆ— 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  li $v0, 5 syscall move $s0, $v0 li $s1, 1 li $s2, 1 beq $s0, 1, one_or_two beq $s0, 2, one_or_two li $t0, 2 for: bgt $t0, $s0, break1 add $s2, $s2, $s1 sub $s1, $s2, $s1 addi $t0, $t0, 1 j for one_or_two: li $a0, 1 li $v0, 1 syscall li $v0, 10 syscall break1: move $a0, $s1 li $v0, 1 syscall li $v0, 10 syscall   æ•°ç»„ 1 2 3  .data Myarray: .space 12 .text     .spaceå°±æ˜¯åœ¨å†…å­˜ä¸­å¼€è¾Ÿäº†ä¸€ä¸ªç›¸åº”å¤§å°çš„ç©ºé—´ã€‚å°±å¦‚ç¤ºä¾‹ä¸­400å°±å¯¹åº”èƒ½å­˜100ä¸ªå­—ï¼ˆ1ä¸ªå­—å››ä¸ªå­—èŠ‚ï¼Œä¸€ä¸ªå­—èŠ‚8ä½ã€‚å†…å­˜æ˜¯ä¸€ä¸ªå­—ä¸€ä¸ªå­—å­˜å‚¨ï¼‰\n  .wordå°±æ˜¯å£°æ˜ä¸€ä¸ª word ç±»å‹çš„å˜é‡ name, åŒæ—¶ç»™å…¶èµ‹å€¼ä¸ºvalue\n  .byteå¹¶ä¸æ˜¯æŒ‰å­—å»ç”³è¯·ç©ºé—´ï¼Œè€Œæ˜¯æŒ‰ç…§å­—èŠ‚\n  .asciizå°±æ˜¯å®šä¹‰ç›¸åº”çš„å­—ç¬¦ä¸²ï¼Œä¾¿äºåç»­çš„è¾“å‡º\n   .asciizä¸.asciiçš„åŒºåˆ«  .ascii å£°æ˜ä½¿ç”¨ ASCII å­—ç¬¦å£°æ˜ä¸€ä¸ªæ–‡æœ¬å­—ç¬¦ä¸²ã€‚å­—ç¬¦ä¸²å…ƒç´ è¢«é¢„å®šä¹‰å¹¶ä¸”å­˜æ”¾åœ¨å†…å­˜ä¸­ï¼Œå…¶èµ·å§‹å†…å­˜ä½ç½®æœ‰ä¾¿ç­¾ outputæŒ‡ç¤ºã€‚ .asciiå’Œ.ascizçš„åŒºåˆ«æ˜¯ï¼Œ.ascizä¼šåœ¨å­—ç¬¦ä¸²åè‡ªåŠ¨æ·»åŠ ç»“æŸç¬¦\\0.    å­—ç¬¦ä¸²éƒ¨åˆ†é€†ç½®  è€ƒå¯Ÿå­—ç¬¦ä¸²çš„è¾“å…¥è¾“å‡º  æ³¨æ„å­—ç¬¦ä¸²åœ¨è¾“å…¥çš„æ—¶å€™æœ‰ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ª$ $a_0$å­˜å‚¨å­—ç¬¦ä¸²çš„é¦–åœ°å€ï¼Œç¬¬äºŒä¸ª$$a_1$å­˜å‚¨å­—ç¬¦ä¸²çš„é•¿åº¦$+1$ï¼ˆå› ä¸ºå­—ç¬¦ä¸²æœ«å°¾éœ€è¦æœ‰ä¸€ä¸ª$NULL(\u0026rsquo;\\setminus0\u0026rsquo;)$ï¼‰   è€ƒå¯Ÿå¯¹å­—ç¬¦çš„æ“ä½œï¼Œå­˜å–åˆ†åˆ«ç”¨$sbã€lb$  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  .data mystring: .space 1010 .text # è¯»å…¥é›¶æ•£æ•°æ® li $v0, 5 syscall move $t0, $v0 #è¯»å…¥n li $v0, 5 syscall move $t1, $v0 #è¯»å…¥x li $v0, 5 syscall move $t2, $v0 #è¯»å…¥y # è¯»å…¥å­—ç¬¦ä¸² li $v0, 8 la $a0, mystring addi $a1, $t0, 1 syscall # è¾“å‡ºxå‰çš„å­—ç¬¦ä¸² li $t3, 0 loop1: bge $t3, $t1, done1 li $v0, 11 lb $a0, mystring($t3) syscall addi $t3, $t3, 1 j loop1 done1: # åè½¬è¾“å‡ºx~yçš„å­—ç¬¦ä¸² addi $t3, $t2, 0 loop2: blt $t3, $t1, done2 li $v0, 11 lb $a0, mystring($t3) syscall addi $t3, $t3, -1 j loop2 done2: # è¾“å‡ºyåçš„å­—ç¬¦ä¸² addi $t3, $t2, 1 loop3: bge $t3, $t0, done3 li $v0, 11 lb $a0, mystring($t3) syscall addi $t3, $t3, 1 j loop3 done3: li $v0, 10 syscall   å†’æ³¡æ’åº 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  .data array: .word 0:101 .text main: # è¯»å…¥æ•°æ® li $v0, 5 syscall move $s0, $v0 # å¾ªç¯è¯»å…¥æ•°ç»„ li $t0, 0 for1: bge $t0, $s0, break1 mul $t1, $t0, 4 li $v0, 5 syscall sw $v0, array($t1) addi $t0, $t0, 1 j for1 break1: # æ’åº li $t0, 0 #iæŒ‡é’ˆ for2: bge $t0, $s0, break2 li $t1, 0 #jæŒ‡é’ˆ addi $t2, $s0, -1 sub $t2, $t2, $t0 for3: bge $t1, $t2, break3 # jä¸j+1çš„åœ°å€ mul $t4, $t1, 4 addi $t5, $t4, 4 lw $s4, array($t4) lw $s5, array($t5) ble $s4, $s5, L sw $s5, array($t4) sw $s4, array($t5) L: addi $t1, $t1, 1 j for3 break3: addi $t0, $t0, 1 j for2 break2: li $t0, 0 for4: bge $t0, $s0, break4 mul $t1, $t0, 4 lw $a0, array($t1) li $v0, 1 syscall addi $t0, $t0, 1 j for4 break4: li $v0, 10 syscall    æ•°ç»„çš„åº”ç”¨ å‡½æ•°çš„è°ƒç”¨ä»¥åŠåœ°å€è¿”å› åœ¨mipsä¸­ä½¿ç”¨é€’å½’å‡½æ•°ï¼ˆç”¨æ ˆæŒ‡é’ˆæ¨¡æ‹Ÿ$spï¼‰  é€’å½’å‡½æ•° é€’å½’çš„åŸºæœ¬ä¾‹ æœ‰å…³æŒ‡ä»¤ 1  jal function #set $ra to Program Counter(PC),then jump to statement at target addres   Cè¯­è¨€ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;stdio.h\u0026gt; int factorial(int n); int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int res = factorial(n); printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } int factorial(int n) { if (n \u0026lt; 1) return 1; else return n * factorial(n - 1); }   MIPSä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  .data prompt1: .asciiz \u0026#34;Enter the number\\n\u0026#34; prompt2: .asciiz \u0026#34;The factorial of n is:\\n\u0026#34; .text # Print prompt1 li $v0, 4 la $a0, prompt1 syscall # Read integer li $v0, 5 syscall #Call factorial move $a0, $v0 jal factorial move $a1, $v0 # save return value to a # Print prompt2 li $v0, 4 la $a0, prompt2 syscall # Print result li $v0, 1 move $a0, $a1 syscall # Exit li $v0, 10 syscall ## Function int factorial(int n) factorial: ## YOUR CODE HERE addi $sp,$sp,-8 #adjust stack for 2 items sw $ra,4($sp) #save return address sw $a0,0($sp) #save the argument n slti $t0,$a0,1 #if n \u0026lt; 1,then set $t0 as 1 beq $t0,$zero,L1 #if equal,then jump L1 #above all,if n \u0026gt;= 1,then jump L1 #if(n \u0026lt; 1) addi $v0,$zero,1 #return 1 addi $sp,$sp,8 #pop 2 items off stack jr $ra #return to caller #else L1: add $a0,$a0,-1 #argument :n - 1 jal factorial #call factorial with (n-1) lw $a0,0($sp) #restore argument n lw $ra,4($sp) #restore address addi $sp,$sp,8 #adjust stack pionter mul $v0,$a0,$v0 #return n * factorial(n-1) jr $ra #return to caller ## END OF YOUR CODE #jr $ra   å¿«æ’  æ ˆæŒ‡é’ˆï¼Œå­˜å‚¨$raä»¥åŠæ¯æ¬¡å¿«æ’çš„åŒºé—´iï¼Œj å‡½æ•°è°ƒç”¨ï¼Œ$raä¸jalç»‘å®šç”¨ä»¥é€’å½’å›æº¯  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148  .data array: .space 4040 comma: .ascii \u0026#34;,\\0\u0026#34; bracket2: .ascii \u0026#34;]\\0\u0026#34; bracket1: .ascii \u0026#34;[\\0\u0026#34; .text init: # è¯»å…¥nçš„å€¼ li $v0, 5 syscall move $s0, $v0 # è¯»å…¥æ•°ç»„å€¼çš„æŒ‡é’ˆï¼Œ$t0 addi $t0, $zero, 0 mul $s0, $s0, 4 input: beq $t0, $s0, input_end # è¯»å…¥ç¬¬iä¸ªå€¼ li $v0, 5 syscall # å­˜è‡³å½“å‰æŒ‡é’ˆå¤„ sw $v0, array($t0) addi $t0, $t0, 4 j input input_end: addi $s3, $zero, 0 addi $s4, $t0, -4 add $sp, $sp, -12 sw $s4, 0($sp) sw $s3, 4($sp) jal quick_sort li $v0, 4 la $a0, bracket1 syscall addi $t0, $zero, 0 output: #è¾“å‡ºç»“æœ li $v0, 1 lw $a0, array($t0) syscall add $t0, $t0, 4 beq $t0, $s0, outputend li $v0, 4 la $a0, comma syscall j output outputend: li $v0, 4 la $a0, bracket2 syscall addi $t0, $zero, 0 # ç»“æŸç¨‹åº li $v0, 10 syscall # å¿«æ’ç®—æ³• quick_sort: # $s3ä¸ºiï¼Œ$s4ä¸ºj lw $s4, 0($sp) lw $s3, 4($sp) sw $ra, 8($sp) bge $s3, $s4, L1 # å½“i\u0026gt;=jæ—¶ï¼Œè·³å‡ºå¾ªç¯ # else j getstandard li $v0, 4 addi $a0, $s5, 0 syscall L: #é€’å½’è°ƒç”¨æ’åº addi $sp, $sp, -24 sw $ra, 20($sp) addi $s6, $s6, -4 sw $s3, 16($sp) sw $s6, 12($sp) sw $ra, 8($sp) addi $s6, $s6, 8 sw $s6, 4($sp) sw $s4, 0($sp) jal quick_sort jal quick_sort lw $ra, 8($sp) addi $sp, $sp, 12 jr $ra L1: addi $sp, $sp, 12 jr $ra getstandard: lw $t3, array($s3) #key addi $s6, $s3, 0 #iæŒ‡é’ˆå¤‡ä»½ addi $s7, $s4, 0 #jæŒ‡é’ˆå¤‡ä»½ while2: bge $s6, $s7, end2 while3: bge $s6, $s7, end3 lw $t2, array($s7) blt $t2, $t3, end3 addi $s7, $s7, -4 j while3 end3: bge $s6, $s7, while4 lw $t2, array($s7) sw $t2, array($s6) while4: bge $s6, $s7, end4 lw $t2, array($s6) bgt $t2, $t3, end4 addi $s6, $s6, 4 j while4 end4: bge $s6, $s7, while2 lw $t2, array($s6) sw $t2, array($s7) j while2 end2: sw $t3, array($s6) j L   åŒºåˆ†lbï¼Œlhï¼Œlwï¼Œåˆ†åˆ«æ˜¯åŠ è½½å­—èŠ‚ï¼ŒåŠå­—ä»¥åŠå­—\n ä¸€ä¸ªå­—èŠ‚ï¼ˆbyteï¼‰æœ‰8ä½ï¼ˆbitsï¼‰ åŠå­—æ˜¯åŠä¸ªå­—ï¼Œ16ä½ï¼Œ2ä¸ªå­—èŠ‚ ä¸€ä¸ªå­—æ˜¯32ä½ï¼Œæœ‰4ä¸ªå­—èŠ‚  åŒç†å¯ä»¥åŒºåˆ†sbï¼Œshï¼Œsw\nå»¶è¿Ÿæ§½\næ±‰è¯ºå¡” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  .data s1: .ascii \u0026#34;-\u0026gt;\\0\u0026#34; line: .ascii \u0026#34;\\n\\0\u0026#34; A: .ascii \u0026#34;A\\0\u0026#34; B: .ascii \u0026#34;B\\0\u0026#34; C: .ascii \u0026#34;C\\0\u0026#34; .text # è¯»å…¥n li $v0, 5 syscall move $s0, $v0 la $s1, A la $s2, B la $s3, C jal hannuo li $v0, 10 syscall # æ±‰è¯ºå¡”å‡½æ•° hannuo: addi $sp, $sp, -20 sw $ra, 0($sp) sw $s0, 4($sp) #å­˜å‚¨n sw $s1, 8($sp) #å­˜å‚¨ç›˜å­A sw $s2, 12($sp)\t#å­˜å‚¨ç›˜å­B sw $s3, 16($sp) #å­˜å‚¨ç›˜å­C beq $s0, 1, move lw $s0, 4($sp) addi $s0, $s0, -1 lw $s1, 8($sp) lw $s2, 16($sp) lw $s3, 12($sp) jal hannuo lw $s1, 8($sp) lw $s3, 16($sp) jal move lw $s0, 4($sp) addi $s0, $s0, -1 lw $s1, 12($sp) lw $s2, 8($sp) lw $s3, 16($sp) jal hannuo # è·³è½¬å›ä¸Šä¸€æ¬¡é€’å½’ lw $ra, 0($sp) addi $sp, $sp, 20 jr $ra move: li $v0, 4 move $a0, $s1 syscall li $v0, 4 la $a0, s1 syscall li $v0, 4 move $a0, $s3 syscall li $v0, 4 la $a0, line syscall lw $s0, 4($sp) beq $s0, 1, L1 jr $ra L1: lw $ra, 0($sp) addi $sp, $sp, 20 jr $ra   ","permalink":"http://appletea233.github.io/myblog_hogo/posts/blog/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/","summary":"åŸºç¡€çŸ¥è¯† å¯„å­˜å™¨ åŸºç¡€æ“ä½œ ç³»ç»Ÿè°ƒç”¨ GCDæœ€å¤§å…¬çº¦æ•° ä¸»è¦è€ƒå¯Ÿå¾ªç¯ï¼Œä½¿ç”¨$j$æŒ‡ä»¤è¿›è¡Œä»£ç å—é—´çš„è·³è½¬ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24","title":"MIPSæ±‡ç¼–åŸºç¡€"},{"content":"å‡½æ•°è°ƒç”¨å…³ç³» ç»“æ„ä½“ä¿¡æ¯ Page 1 2 3 4 5 6 7 8 9  struct Page_list{ struct { struct { struct Page *le_next; struct Page le_prev; } pp_link; u_short pp_ref; }* lh_first; // Page* }    Env_listç»“æ„ä¸ä¹‹ç±»ä¼¼  Trapframe 1 2 3 4 5 6 7 8 9 10 11 12 13  struct Trapframe { //lr:need to be modified(reference to linux pt_regs) TODO \t/* Saved main processor registers. */ unsigned long regs[32]; /* Saved special registers. */ unsigned long cp0_status; unsigned long hi; unsigned long lo; unsigned long cp0_badvaddr; unsigned long cp0_cause; unsigned long cp0_epc; unsigned long pc; };   Env 1 2 3 4 5 6 7 8 9 10 11  struct Env { struct Trapframe env_tf; // Saved registers  LIST_ENTRY(Env) env_link; // Free LIST_ENTRY  u_int env_id; // Unique environment identifier  u_int env_parent_id; // env_id of this env\u0026#39;s parent  u_int env_status; // Status of the environment  Pde *env_pgdir; // Kernel virtual address of page dir  u_int env_cr3; LIST_ENTRY(Env) env_sched_link; u_int env_pri; };    env_status : è¯¥å˜é‡åªèƒ½æœ‰ä»¥ä¸‹ä¸‰ç§å–å€¼ï¼š   ENV_FREE : è¡¨æ˜è¯¥è¿›ç¨‹æ˜¯ä¸æ´»åŠ¨çš„ï¼Œå³è¯¥è¿›ç¨‹æ§åˆ¶å—å¤„äºè¿›ç¨‹ç©ºé—²é“¾è¡¨ä¸­ã€‚ ENV_NOT_RUNNABLE : è¡¨æ˜è¯¥è¿›ç¨‹å¤„äºé˜»å¡çŠ¶æ€ï¼Œå¤„äºè¯¥çŠ¶æ€çš„è¿›ç¨‹éœ€è¦åœ¨ä¸€å®šæ¡ä»¶ä¸‹å˜æˆå°±ç»ªçŠ¶æ€ä»è€Œè¢«CPUè°ƒåº¦ã€‚ï¼ˆæ¯”å¦‚å› è¿›ç¨‹é€šä¿¡é˜»å¡æ—¶å˜ä¸º ENV_NOT_RUNNABLEï¼Œæ”¶åˆ°ä¿¡æ¯åå˜å› ENV_RUNNABLEï¼‰ ENV_RUNNABLE : è¡¨æ˜è¯¥è¿›ç¨‹å¤„äºæ‰§è¡ŒçŠ¶æ€æˆ–å°±ç»ªçŠ¶æ€ï¼Œå³å…¶å¯èƒ½æ˜¯æ­£åœ¨è¿è¡Œçš„ï¼Œä¹Ÿå¯èƒ½æ­£åœ¨ç­‰å¾…è¢«è°ƒåº¦ã€‚  Ehdrä¸Phdr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  typedef struct { unsigned char\te_ident[EI_NIDENT];\t/* Magic number and other info */ Elf32_Half\te_type;\t/* Object file type */ Elf32_Half\te_machine;\t/* Architecture */ Elf32_Word\te_version;\t/* Object file version */ Elf32_Addr\te_entry;\t/* Entry point virtual address */ Elf32_Off\te_phoff;\t/* Program header table file offset */ Elf32_Off\te_shoff;\t/* Section header table file offset */ Elf32_Word\te_flags;\t/* Processor-specific flags */ Elf32_Half\te_ehsize;\t/* ELF header size in bytes */ Elf32_Half\te_phentsize;\t/* Program header table entry size */ Elf32_Half\te_phnum;\t/* Program header table entry count */ Elf32_Half\te_shentsize;\t/* Section header table entry size */ Elf32_Half\te_shnum;\t/* Section header table entry count */ Elf32_Half\te_shstrndx;\t/* Section header string table index */ } Elf32_Ehdr;   1 2 3 4 5 6 7 8 9 10  typedef struct { Elf32_Word\tp_type;\t/* Segment type */ Elf32_Off\tp_offset;\t/* Segment file offset */ Elf32_Addr\tp_vaddr;\t/* Segment virtual address */ Elf32_Addr\tp_paddr;\t/* Segment physical address */ Elf32_Word\tp_filesz;\t/* Segment size in file */ Elf32_Word\tp_memsz;\t/* Segment size in memory */ Elf32_Word\tp_flags;\t/* Segment flags */ Elf32_Word\tp_align;\t/* Segment alignment */ } Elf32_Phdr;   ä¸€äº›å…¨å±€å˜é‡ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  // env.h ./include/env.h:11:#define LOG2NENV 10 ./include/env.h:12:#define NENV (1\u0026lt;\u0026lt;LOG2NENV) ./include/env.h:13:#define ENVX(envid) ((envid) \u0026amp; (NENV - 1)) // env.c struct Env *envs = NULL; // All environments struct Env *curenv = NULL; // the current env  static struct Env_list env_free_list; // Free list struct Env_list env_sched_list[2]; // Runnable list  extern Pde *boot_pgdir; extern char *KERNEL_SP; static u_int asid_bitmap[2] = {0}; // 64  // mmu.c ./include/error.h:8:#define E_BAD_ENV 2 // Environment doesn\u0026#39;t exist or otherwise ./include/mmu.h:109:#define E_BAD_ENV 2 // Environment doesn\u0026#39;t exist or otherwise  // pageç›¸å…³ #define BY2PG\t4096\t// bytes to a page #define PDMAP\t(4*1024*1024)\t// bytes mapped by a page directory entry #define PGSHIFT\t12 #define PDSHIFT\t22\t// log2(PDMAP) #define PDX(va)\t((((u_long)(va))\u0026gt;\u0026gt;22) \u0026amp; 0x03FF) // å–é¡µç›®å½•åºå· #define PTX(va)\t((((u_long)(va))\u0026gt;\u0026gt;12) \u0026amp; 0x03FF) // å–...åºå· #define PTE_ADDR(pte)\t((u_long)(pte)\u0026amp;~0xFFF)  // page number field of address #define PPN(va)\t(((u_long)(va))\u0026gt;\u0026gt;12) #define VPN(va)\tPPN(va)  #define VA2PFN(va)\t(((u_long)(va)) \u0026amp; 0xFFFFF000 ) // va 2 PFN for EntryLo0/1 #define PTE2PT\t1024  // å†…å­˜åœ°å›¾ #define KERNBASE 0x80010000  #define VPT (ULIM + PDMAP ) #define KSTACKTOP (VPT-0x100) #define KSTKSIZE (8*BY2PG) #define ULIM 0x80000000\t #define UVPT (ULIM - PDMAP) #define UPAGES (UVPT - PDMAP) #define UENVS (UPAGES - PDMAP) #define UTOP UENVS  #define UXSTACKTOP (UTOP) #define TIMESTACK 0x82000000  #define PTE_ADDR(pte) ((u_long)(pte)\u0026amp;~0xFFF)   0x00400000\nå˜é‡è½¬æ¢  page2ppn page2pa page2kvaï¼šå°†é¡µè½¬æ¢ä¸ºå†…æ ¸çš„è™šæ‹Ÿåœ°å€ va2pa  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  LIST_HEAD(Page_list, Page); typedef LIST_ENTRY(Page) Page_LIST_entry_t; struct Page { Page_LIST_entry_t pp_link;\t/* free list link */ // Ref is the count of pointers (usually in page table entries) \t// to this page. This only holds for pages allocated using \t// page_alloc. Pages allocated at boot time using pmap.c\u0026#39;s \u0026#34;alloc\u0026#34; \t// do not have valid reference count fields.  u_short pp_ref; }; extern struct Page *pages; static inline u_long page2ppn(struct Page *pp) { return pp - pages; } static inline u_long page2pa(struct Page *pp) { return page2ppn(pp)\u0026lt;\u0026lt;PGSHIFT; } static inline struct Page * pa2page(u_long pa) { if (PPN(pa) \u0026gt;= npage) panic(\u0026#34;pa2page called with invalid pa: %x\u0026#34;, pa); return \u0026amp;pages[PPN(pa)]; } static inline u_long page2kva(struct Page *pp) { return KADDR(page2pa(pp)); } static inline u_long va2pa(Pde *pgdir, u_long va) { Pte *p; pgdir = \u0026amp;pgdir[PDX(va)]; if (!(*pgdir\u0026amp;PTE_V)) return ~0; p = (Pte*)KADDR(PTE_ADDR(*pgdir)); if (!(p[PTX(va)]\u0026amp;PTE_V)) return ~0; return PTE_ADDR(p[PTX(va)]); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #define ULIM 0x80000000 #define PADDR(kva)\t\\ ({\t\\ u_long a = (u_long) (kva);\t\\ if (a \u0026lt; ULIM)\t\\ panic(\u0026#34;PADDR called with invalid kva %08lx\u0026#34;, a);\\ a - ULIM;\t\\ })  // translates from physical address to kernel virtual address #define KADDR(pa)\t\\ ({\t\\ u_long ppn = PPN(pa);\t\\ if (ppn \u0026gt;= npage)\t\\ panic(\u0026#34;KADDR called with invalid pa %08lx\u0026#34;, (u_long)pa);\\ (pa) + ULIM;\t\\ })   Exercise exercise 3.1  ä½¿ç”¨boot_map_segmentè¿›è¡Œæ®µæ˜ å°„ï¼Œenvs æ•°ç»„åº”è¯¥è¢«UENVS åŒºåŸŸæ˜ å°„  exercise 3.2  ä½¿ç”¨envså‡½æ•°ï¼Œæ³¨æ„queue.hå‡½æ•°è°ƒç”¨çš„å‚æ•°ç±»å‹ã€‚ æ’å…¥é¡ºåºä¸ºå€’åº  exercise 3.3 å…³äºasid_allocå‡½æ•° asid_alloc å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯ä¸ºæ–°åˆ›å»ºçš„è¿›ç¨‹åˆ†é…ä¸€ä¸ªå¼‚äºå½“å‰æ‰€æœ‰æœªè¢«é‡Šæ”¾çš„è¿›ç¨‹çš„ ASIDã€‚\n  è¿™ä¸ª ASIDæ˜¯ä»€ä¹ˆï¼Ÿ\n  ä¸ºä»€ä¹ˆè¦ä¸å…¶ä»–çš„è¿›ç¨‹ä¸åŒå‘¢ï¼Ÿ\n  æ ¹æ® lab2 çš„å­¦ä¹ æˆ‘ä»¬å¾—çŸ¥è¿›ç¨‹æ˜¯é€šè¿‡é¡µè¡¨æ¥è®¿é—®å†…å­˜çš„ï¼Œè€Œä¸åŒçš„è¿›ç¨‹çš„åŒä¸€ä¸ªè™šæ‹Ÿåœ°å€å¯èƒ½ä¼šæ˜ å°„åˆ°ä¸åŒçš„ç‰©ç†åœ°å€ã€‚\nä¸ºäº†å®ç°è¿™ä¸ªåŠŸèƒ½ï¼ŒTLB ä¸­é™¤äº†å­˜å‚¨é¡µè¡¨çš„æ˜ å°„ä¿¡æ¯ä¹‹å¤–ï¼Œè¿˜ä¼šå­˜å‚¨è¿›ç¨‹çš„æ ‡è¯†ç¼–å·ï¼Œä½œä¸º Key çš„ä¸€éƒ¨åˆ†ï¼Œç”¨äºä¿è¯æŸ¥åˆ°çš„é¡µé¢æ˜ å°„å±äºå½“å‰è¿›ç¨‹ï¼Œè€Œè¿™ä¸ªç¼–å·å°±æ˜¯ASIDã€‚æ˜¾ç„¶ï¼Œä¸åŒè¿›ç¨‹çš„è™šæ‹Ÿåœ°å€æ˜¯å¯ä»¥å¯¹åº”ç›¸åŒ VPN çš„ï¼Œè€Œå¦‚æœ ASID ä¹Ÿä¸å…·å¤‡å”¯ä¸€æ ‡è¯†æ€§ï¼Œå°±ä¸ TLB Field çš„å”¯ä¸€æ€§è¦æ±‚ç›¸çŸ›ç›¾äº†ã€‚å› æ­¤ï¼Œç›´åˆ°è¿›ç¨‹è¢«é”€æ¯æˆ– TLB è¢«æ¸…ç©ºæ—¶ï¼Œæ‰å¯ä»¥æŠŠè¿™ä¸ª ASID åˆ†é…ç»™å…¶ä»–è¿›ç¨‹ã€‚\n ä¸ºä»€ä¹ˆä¸èƒ½ç®€å•çš„é€šè¿‡è‡ªå¢æ¥é¿å…å†²çªå‘¢ï¼Ÿ  ç®€å•çš„å›ç­”ï¼šç”¨æ¥å­˜å‚¨ASIDçš„ä½æ•°æœ‰é™ï¼Œè‡ªå¢å®¹æ˜“å‘ç”Ÿæº¢å‡º\nexercise 3.4 env_setup_vm 1 2 3 4 5 6 7 8 9  static int env_setup_vm(struct Env *e); for (i = 0; i \u0026lt; PDX(UTOP); i++){ pgdir[i] = 0; } for (i = PDX(UTOP); i\u0026lt;PTE2PT; i++){ if (i != PDX(VPT) \u0026amp;\u0026amp; i != PDX(UVPT)) pgdir[i] = boot_pgdir[i]; }    å¾ˆå¤šç–‘é—® å…³äºboot_pgdir  exercise 3.5 env_alloc 1 2  // è®¾ç½®spå¯„å­˜å™¨ e-\u0026gt;env_tf.regs[29] = USTACKTOP;   exercise 3.6 load_icode_mapper\t è°ƒç”¨é“¾ï¼šload_icode -\u0026gt; load_elf -\u0026gt; load_icode_mapper\nexercise 3.7 load_elfå’Œload_icode exercise 3.8 env_create å’Œenv_create_priority è°ƒç”¨é“¾ï¼šenv_create -\u0026gt; env_create_priority\nexercise 3.9 mips_init exercise 3.10 env_run exercise 3.11 page_init Thinking Thinking 3.1 æ€è€ƒenvid2env å‡½æ•°:\nä¸ºä»€ä¹ˆenvid2env ä¸­éœ€è¦åˆ¤æ–­e-\u0026gt;env_id != envid çš„æƒ…å†µï¼Ÿå¦‚æœæ²¡æœ‰è¿™æ­¥åˆ¤æ–­ä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µï¼Ÿ\n envidå¯èƒ½å¤§äº64 æ²¡æœ‰è¿™ä¸€æ­¥å¯èƒ½å¯¼è‡´éå†…å­˜æ§åˆ¶å¿«çš„å†…å­˜åœ°å€è¢«è½¬æ¢  Thinking 3.2 ç»“åˆinclude/mmu.h ä¸­çš„åœ°å€ç©ºé—´å¸ƒå±€ï¼Œæ€è€ƒenv_setup_vm å‡½æ•°ï¼š\n UTOP å’ŒULIM çš„å«ä¹‰åˆ†åˆ«æ˜¯ä»€ä¹ˆï¼ŒUTOP å’ŒULIM ä¹‹é—´çš„åŒºåŸŸä¸UTOPä»¥ä¸‹çš„åŒºåŸŸç›¸æ¯”æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ   ULIMä»¥ä¸Šæ˜¯å†…æ ¸æ€ UTOPä¸ULIMä¹‹é—´æœ‰ä¸‰ä¸ªé¡µè¡¨ ULIMä¹‹ä¸‹çš„æ˜¯æ ˆï¼ŒUTOPå’ŒULIMä¹‹é—´çš„åŒºåŸŸæ˜¯é¡µè¡¨   è¯·ç»“åˆç³»ç»Ÿè‡ªæ˜ å°„æœºåˆ¶è§£é‡Šä»£ç ä¸­pgdir[PDX(UVPT)]=env_cr3çš„å«ä¹‰ã€‚  è‡ªèº«æ˜ å°„åˆ°è‡ªèº«\n è°ˆè°ˆè‡ªå·±å¯¹è¿›ç¨‹ä¸­ç‰©ç†åœ°å€å’Œè™šæ‹Ÿåœ°å€çš„ç†è§£ã€‚  ä¹‹é—´æœ‰æ˜ å°„å…³ç³»ã€‚\nThinking 3.3 æ‰¾åˆ° user_data è¿™ä¸€å‚æ•°çš„æ¥æºï¼Œæ€è€ƒå®ƒçš„ä½œç”¨ã€‚æ²¡æœ‰è¿™ä¸ªå‚æ•°å¯ä¸å¯ä»¥ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿï¼ˆå¯ä»¥å°è¯•è¯´æ˜å®é™…çš„åº”ç”¨åœºæ™¯ï¼Œä¸¾ä¸€ä¸ªå®é™…çš„åº“ä¸­çš„ä¾‹å­ï¼‰\n ä¸ºload_icode_mapperä¼ å‚  Thinking 3.4 ç»“åˆload_icode_mapper çš„å‚æ•°ä»¥åŠäºŒè¿›åˆ¶é•œåƒçš„å¤§å°ï¼Œè€ƒè™‘è¯¥å‡½æ•°å¯èƒ½ä¼šé¢ä¸´å“ªå‡ ç§å¤åˆ¶çš„æƒ…å†µï¼Ÿä½ æ˜¯å¦éƒ½è€ƒè™‘åˆ°äº†ï¼Ÿ\n vaä¸ä¸é¡µå¯¹å…¶ va+binsizeä¸ä¸é¡µé¢å¯¹é½  Thinking 3.5 æ€è€ƒä¸Šé¢è¿™ä¸€æ®µè¯ï¼Œå¹¶æ ¹æ®è‡ªå·±åœ¨lab2 ä¸­çš„ç†è§£ï¼Œå›ç­”ï¼š\n ä½ è®¤ä¸ºè¿™é‡Œçš„ env_tf.pc å­˜å‚¨çš„æ˜¯ç‰©ç†åœ°å€è¿˜æ˜¯è™šæ‹Ÿåœ°å€?  æ˜¯è™šæ‹Ÿåœ°å€\n ä½ è§‰å¾—entry_pointå…¶å€¼å¯¹äºæ¯ä¸ªè¿›ç¨‹æ˜¯å¦ä¸€æ ·ï¼Ÿè¯¥å¦‚ä½•ç†è§£è¿™ç§ç»Ÿä¸€æˆ–ä¸åŒ  ä¸ä¸€å®šç›¸åŒï¼Œå¯¹ä¸åŒçš„elfæ–‡ä»¶entry_pointä¸åŒã€‚\nThinking 3.6 è¯·æŸ¥é˜…ç›¸å…³èµ„æ–™è§£é‡Šï¼Œä¸Šé¢æåˆ°çš„epcæ˜¯ä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆè¦å°†env_tf.pcè®¾ç½®ä¸ºepcå‘¢ï¼Ÿ\nThinking 3.7 å…³äº TIMESTACKï¼Œè¯·æ€è€ƒä»¥ä¸‹é—®é¢˜ï¼š\n æ“ä½œç³»ç»Ÿåœ¨ä½•æ—¶å°†ä»€ä¹ˆå†…å®¹å­˜åˆ°äº† TIMESTACK åŒºåŸŸ TIMESTACK å’Œ env_asm.S ä¸­æ‰€å®šä¹‰çš„ KERNEL_SP çš„å«ä¹‰æœ‰ä½•ä¸åŒ  Thinking 3.8 è¯•æ‰¾å‡ºä¸Šè¿° 5 ä¸ªå¼‚å¸¸å¤„ç†å‡½æ•°çš„å…·ä½“å®ç°ä½ç½®ã€‚\n   å¼‚å¸¸å· å¤„ç†å‡½æ•° å«ä¹‰ å…·ä½“å®ç°ä½ç½® å¤‡æ³¨     0 handle_int è¡¨ç¤ºä¸­æ–­ï¼Œç”±æ—¶é’Ÿä¸­æ–­ã€æ§åˆ¶å°ä¸­æ–­ç­‰ä¸­æ–­é€ æˆ ./lib/genex.S    1 handle_mod è¡¨ç¤ºå­˜å‚¨å¼‚å¸¸ï¼Œè¿›è¡Œå­˜å‚¨æ“ä½œæ—¶è¯¥é¡µè¢«æ ‡è®°ä¸ºåªè¯» ./lib/genex.S    2 handle_tlb TLB å¼‚å¸¸ï¼ŒTLB ä¸­æ²¡æœ‰å’Œç¨‹åºåœ°å€åŒ¹é…çš„æœ‰æ•ˆå…¥å£ ./lib/genex.S    3 handle_tlb TLB å¼‚å¸¸ï¼ŒTLB å¤±æ•ˆï¼Œä¸”æœªå¤„äºå¼‚å¸¸æ¨¡å¼ï¼ˆç”¨äºæé«˜å¤„ç†æ•ˆç‡ï¼‰ ./lib/genex.S    8 handle_sys ç³»ç»Ÿè°ƒç”¨ï¼Œé™·å…¥å†…æ ¸ï¼Œæ‰§è¡Œäº† syscall æŒ‡ä»¤ ./lib/syscall.S     Thinking 3.9 é˜…è¯» kclock_asm.S å’Œ genex.S ä¸¤ä¸ªæ–‡ä»¶ï¼Œå¹¶å°è¯•è¯´å‡º set_timer å’Œtimer_irq å‡½æ•°ä¸­æ¯è¡Œæ±‡ç¼–ä»£ç çš„ä½œç”¨\nset_timer 1 2 3 4 5 6 7 8 9 10  LEAF(set_timer) li t0, 0xc8 sb t0, 0xb5000100\t// å‘0xb5000100 ä½ç½®å†™å…¥0xc8 sw\tsp, KERNEL_SP\t// å°†å½“å‰æ ˆæŒ‡é’ˆä¿å­˜åˆ°KERNEL_SP setup_c0_status STATUS_CU0|0x1001 0\t// è°ƒç”¨setup_c0_statuså‡½æ•° jr ra nop END(set_timer)   time_irq 1 2 3 4 5 6 7 8 9 10 11 12 13  timer_irq: sb zero, 0xb5000110\t// åœ¨0xb5000110å†™å…¥0 1:\tj\tsched_yield\t// è·³è½¬åˆ°sched_ yield nop /*li t1, 0xff lw t0, delay addu t0, 1 sw\tt0, delay beq\tt0,t1,1f\tnop*/ j\tret_from_exception\tnop   è¦äº§ç”Ÿæ—¶é’Ÿä¸­æ–­ï¼Œæˆ‘ä»¬ä¸ä»…è¦äº†è§£ä¸­æ–­çš„äº§ç”Ÿä¸å¤„ç†ï¼Œè¿˜è¦äº†è§£ gxemul æ˜¯å¦‚ä½•æ¨¡æ‹Ÿæ—¶é’Ÿä¸­æ–­çš„ã€‚kclock_init å‡½æ•°å®Œæˆäº†æ—¶é’Ÿçš„åˆå§‹åŒ–ï¼Œè¯¥å‡½æ•°ä¸»è¦è°ƒç”¨ set_timer å‡½æ•°ï¼Œå®Œæˆå¦‚ä¸‹æ“ä½œï¼š\n é¦–å…ˆå‘0xb5000100 ä½ç½®å†™å…¥0xc8ï¼Œå…¶ä¸­0xb5000000 æ˜¯æ¨¡æ‹Ÿå™¨(gxemul) æ˜ å°„å®æ—¶é’Ÿçš„ä½ç½®ã€‚åç§»é‡ä¸º0x100 è¡¨ç¤ºæ¥è®¾ç½®å®æ—¶é’Ÿä¸­æ–­çš„é¢‘ç‡ï¼Œ0xc8 åˆ™è¡¨ç¤º1 ç§’é’Ÿä¸­æ–­200æ¬¡ï¼Œå¦‚æœå†™å…¥0ï¼Œè¡¨ç¤ºå…³é—­å®æ—¶é’Ÿã€‚å®æ—¶é’Ÿå¯¹äºR3000 æ¥è¯´ç»‘å®šåˆ°äº†4 å·ä¸­æ–­ä¸Šï¼Œæ•…è¿™æ®µä»£ç å…¶å®ä¸»è¦ç”¨æ¥è§¦å‘äº†4 å·ä¸­æ–­ã€‚æ³¨æ„è¿™é‡Œçš„ä¸­æ–­å·å’Œå¼‚å¸¸å·æ˜¯ä¸ä¸€æ ·çš„æ¦‚å¿µï¼Œæˆ‘ä»¬å®éªŒçš„å¼‚å¸¸åŒ…æ‹¬ä¸­æ–­ã€‚ ä¸€æ—¦å®æ—¶é’Ÿä¸­æ–­äº§ç”Ÿï¼Œå°±ä¼šè§¦å‘MIPS ä¸­æ–­ï¼Œä»è€ŒMIPS å°†PC æŒ‡å‘0x80000080ï¼Œä»è€Œè·³è½¬åˆ°.text.exc_vec3ä»£ç æ®µæ‰§è¡Œã€‚å¯¹äºå®æ—¶é’Ÿå¼•èµ·çš„ä¸­æ–­ï¼Œé€šè¿‡.text.exc_vec3ä»£ç æ®µçš„åˆ†å‘ï¼Œæœ€ç»ˆä¼šè°ƒç”¨handle_ int å‡½æ•°æ¥å¤„ç†å®æ—¶é’Ÿä¸­æ–­ã€‚ åœ¨handle_ int åˆ¤æ–­CP0_CAUSEå¯„å­˜å™¨æ˜¯ä¸æ˜¯å¯¹åº”çš„4 å·ä¸­æ–­ä½å¼•å‘çš„ä¸­æ–­ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™æ‰§è¡Œä¸­æ–­æœåŠ¡å‡½æ•°timer_ irqã€‚ åœ¨timer_ irq é‡Œç›´æ¥è·³è½¬åˆ°sched_ yield ä¸­æ‰§è¡Œã€‚è€Œè¿™ä¸ªå‡½æ•°å°±æ˜¯æˆ‘ä»¬å°†è¦è¡¥å……çš„è°ƒåº¦å‡½æ•°ã€‚  SAVE_ALL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  .macro SAVE_ALL // å‰å››è¡Œå…¶é¦–å…ˆå–å‡ºäº† SR å¯„å­˜å™¨çš„å€¼, ç„¶ååˆ©ç”¨ç§»ä½ç­‰æ“ä½œåˆ¤æ–­ç¬¬ 28 ä½çš„å€¼, æ ¹æ®å‰é¢çš„è®²è¿°æˆ‘ä»¬å¯ä»¥çŸ¥é“, ä¹Ÿå³åˆ¤æ–­å½“å‰æ˜¯å¦å¤„äºç”¨æˆ·æ¨¡å¼ä¸‹ã€‚5 mfc0\tk0,CP0_STATUS sll\tk0,3 /* extract cu0 bit */ bltz\tk0,1f nop /* * Called from user mode, new stack */ // lui\tk1,%hi(kernelsp) // lw\tk1,%lo(kernelsp)(k1) //not clear right now // æ¥ä¸‹æ¥å°†å½“å‰è¿è¡Œæ ˆçš„åœ°å€ä¿å­˜åˆ° k0 ä¸­ï¼›ç„¶åè°ƒç”¨ get_sp å®ï¼Œæ ¹æ®ä¸­æ–­å¼‚å¸¸çš„ç§ç±»åˆ¤æ–­éœ€è¦ä¿å­˜çš„ä½ç½®ï¼Œå¹¶åˆ†é…ä¸€å®šçš„ç©ºé—´ï¼›å°†ä¹‹å‰çš„è¿è¡Œæ ˆåœ°å€ä¸ 2 å·å¯„å­˜å™¨ $v0 å…ˆä¿å­˜èµ·æ¥ï¼Œä¾¿äºåé¢å¯ä»¥æ”¾å¿ƒçš„ä½¿ç”¨ sp å¯„å­˜å™¨ä¸ v0 å¯„å­˜å™¨ã€‚ 1: move\tk0,sp get_sp move\tk1,sp subu\tsp,k1,TF_SIZE sw\tk0,TF_REG29(sp) sw\t$2,TF_REG2(sp) mfc0\tv0,CP0_STATUS sw\tv0,TF_STATUS(sp) mfc0\tv0,CP0_CAUSE sw\tv0,TF_CAUSE(sp) mfc0\tv0,CP0_EPC sw\tv0,TF_EPC(sp) mfc0\tv0, CP0_BADVADDR sw\tv0, TF_BADVADDR(sp) mfhi\tv0 sw\tv0,TF_HI(sp) mflo\tv0 sw\tv0,TF_LO(sp) sw\t$0,TF_REG0(sp) sw\t$1,TF_REG1(sp) //sw\t$2,TF_REG2(sp) sw\t$3,TF_REG3(sp) sw\t$4,TF_REG4(sp) sw\t$5,TF_REG5(sp) sw\t$6,TF_REG6(sp) sw\t$7,TF_REG7(sp) sw\t$8,TF_REG8(sp) sw\t$9,TF_REG9(sp) sw\t$10,TF_REG10(sp) sw\t$11,TF_REG11(sp) sw\t$12,TF_REG12(sp) sw\t$13,TF_REG13(sp) sw\t$14,TF_REG14(sp) sw\t$15,TF_REG15(sp) sw\t$16,TF_REG16(sp) sw\t$17,TF_REG17(sp) sw\t$18,TF_REG18(sp) sw\t$19,TF_REG19(sp) sw\t$20,TF_REG20(sp) sw\t$21,TF_REG21(sp) sw\t$22,TF_REG22(sp) sw\t$23,TF_REG23(sp) sw\t$24,TF_REG24(sp) sw\t$25,TF_REG25(sp) sw\t$26,TF_REG26(sp) sw\t$27,TF_REG27(sp) sw\t$28,TF_REG28(sp) sw\t$30,TF_REG30(sp) sw\t$31,TF_REG31(sp) .endm   å†…å­˜åœ°å›¾ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  /* o 4G -----------\u0026gt; +----------------------------+------------0x100000000 o | ... | kseg3 o +----------------------------+------------0xe000 0000 o | ... | kseg2 o +----------------------------+------------0xc000 0000 o | Interrupts \u0026amp; Exception | kseg1 o +----------------------------+------------0xa000 0000 o | Invalid memory | /|\\ o +----------------------------+----|-------Physics Memory Max o | ... | kseg0 o VPT,KSTACKTOP-----\u0026gt; +----------------------------+----|-------0x8040 0000-------end o | Kernel Stack | | KSTKSIZE /|\\ o +----------------------------+----|------ | o | Kernel Text | | PDMAP o KERNBASE -----\u0026gt; +----------------------------+----|-------0x8001 0000 | o | Interrupts \u0026amp; Exception | \\|/ \\|/ o ULIM -----\u0026gt; +----------------------------+------------0x8000 0000------- o | User VPT | PDMAP /|\\ o UVPT -----\u0026gt; +----------------------------+------------0x7fc0 0000 | o | PAGES | PDMAP | o UPAGES -----\u0026gt; +----------------------------+------------0x7f80 0000 | o | ENVS | PDMAP | o UTOP,UENVS -----\u0026gt; +----------------------------+------------0x7f40 0000 | o UXSTACKTOP -/ | user exception stack | BY2PG | o +----------------------------+------------0x7f3f f000 | o | Invalid memory | BY2PG | o USTACKTOP ----\u0026gt; +----------------------------+------------0x7f3f e000 | o | normal user stack | BY2PG | o +----------------------------+------------0x7f3f d000 | a | | | a ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | a . . | a . . kuseg a . . | a |~~~~~~~~~~~~~~~~~~~~~~~~~~~~| | a | | | o UTEXT -----\u0026gt; +----------------------------+ | o | | 2 * PDMAP \\|/ a 0 ------------\u0026gt; +----------------------------+ ----------------------------- o */    boot_pgdir è¢«æ˜ å°„åˆ°UPAGES envsè¢«æ˜ å°„åˆ°UENVS  04000000\nå¼‚å¸¸ä¸ä¸­æ–­ æˆ‘ä»¬å®éªŒé‡Œè®¤ä¸ºå‡¡æ˜¯å¼•èµ·æ§åˆ¶æµçªå˜çš„éƒ½å«åšå¼‚å¸¸ï¼Œè€Œä¸­æ–­ä»…ä»…æ˜¯å¼‚å¸¸çš„ä¸€ç§ï¼Œå¹¶ä¸”æ˜¯ä»…æœ‰çš„ä¸€ç§å¼‚æ­¥å¼‚å¸¸ã€‚\nå¼‚å¸¸çš„äº§ç”Ÿä¸è¿”å› ","permalink":"http://appletea233.github.io/myblog_hogo/posts/blog/%E6%96%87%E6%A1%A3/","summary":"å‡½æ•°è°ƒç”¨å…³ç³» ç»“æ„ä½“ä¿¡æ¯ Page 1 2 3 4 5 6 7 8 9 struct Page_list{ struct { struct { struct Page *le_next; struct Page le_prev; } pp_link; u_short pp_ref; }* lh_first; // Page* } Env_listç»“æ„ä¸ä¹‹ç±»ä¼¼ Trapframe 1 2 3 4 5 6 7 8 9 10 11 12 13","title":"BUAAæ“ä½œç³»ç»Ÿlab3ç¬”è®°"},{"content":"hhhhh æˆ‘çš„ç¬¬ä¸€ç¯‡åšå®¢\nhhhhhhh 1  printf(\u0026#34;hello world\u0026#34;);   ","permalink":"http://appletea233.github.io/myblog_hogo/posts/blog/my-first-post/","summary":"hhhhh æˆ‘çš„ç¬¬ä¸€ç¯‡åšå®¢ hhhhhhh 1 printf(\u0026#34;hello world\u0026#34;);","title":"My First Post"},{"content":"","permalink":"http://appletea233.github.io/myblog_hogo/tags/","summary":"","title":"ğŸ”–æ ‡ç­¾"},{"content":"","permalink":"http://appletea233.github.io/myblog_hogo/about/","summary":"","title":"ğŸ™‹ğŸ»â€â™‚ï¸å…³äº"},{"content":" Appletea\u0026#39;s Blog ä¸€ä¸ªè®°å½•å­¦ä¹ ã€ç”Ÿæ´»çš„åšå®¢     Appletea\u0026#39;s Blog ä¸€ä¸ªè®°å½•å­¦ä¹ ã€ç”Ÿæ´»çš„åšå®¢    ","permalink":"http://appletea233.github.io/myblog_hogo/links/","summary":"Appletea\u0026#39;s Blog ä¸€ä¸ªè®°å½•å­¦ä¹ ã€ç”Ÿæ´»çš„åšå®¢ Appletea\u0026#39;s Blog ä¸€ä¸ªè®°å½•å­¦ä¹ ã€ç”Ÿæ´»çš„åšå®¢","title":"ğŸ¤å‹é“¾"}]