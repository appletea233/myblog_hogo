[{"content":"基础知识 寄存器 基础操作 系统调用 GCD最大公约数  主要考察循环，使用$j$指令进行代码块间的跳转  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  .data .text # 读入数据 li $v0 5 syscall addi $t0, $v0, 0 li $v0 5 syscall addi $t1, $v0, 0 # 循环求公约数 while: beqz $t1, next div $t0, $t1 move $t0, $t1 mfhi $s0 addi $t1, $s0, 0 j while next: addi $a0, $t0, 0 li $v0, 1 syscall li $v0, 10 syscall   约瑟夫问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  .data v: .word 1:110 .text main: li $v0, 5 syscall move $s0, $v0 # 存储n li $v0, 5 syscall move $s1, $v0 # 存储m li $v0, 5 syscall move $s2, $v0 # 存储k addi $t0, $s0, 0 # 当前人数alive addi $t1, $s2, 0 # 当前轮到的人index move $t2, $0 #当前轮次轮到过的人数num while1: beq $t0, 0, out1 mul $t3, $t1, 4 lw $t4, v($t3) add $t2, $t2, $t4 bne $t2, $s1, L sw $0, v($t3) addi $t0, $t0, -1 move $t2, $0 addi $a0, $t1, 1 li $v0, 1 syscall L: addi $t1, $t1, 1 bne $t1, $s0, L2 move $t1, $0 L2: j while1 out1: li $v0, 10 syscall   斐波那契数列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  li $v0, 5 syscall move $s0, $v0 li $s1, 1 li $s2, 1 beq $s0, 1, one_or_two beq $s0, 2, one_or_two li $t0, 2 for: bgt $t0, $s0, break1 add $s2, $s2, $s1 sub $s1, $s2, $s1 addi $t0, $t0, 1 j for one_or_two: li $a0, 1 li $v0, 1 syscall li $v0, 10 syscall break1: move $a0, $s1 li $v0, 1 syscall li $v0, 10 syscall   数组 1 2 3  .data Myarray: .space 12 .text     .space就是在内存中开辟了一个相应大小的空间。就如示例中400就对应能存100个字（1个字四个字节，一个字节8位。内存是一个字一个字存储）\n  .word就是声明一个 word 类型的变量 name, 同时给其赋值为value\n  .byte并不是按字去申请空间，而是按照字节\n  .asciiz就是定义相应的字符串，便于后续的输出\n   .asciiz与.ascii的区别  .ascii 声明使用 ASCII 字符声明一个文本字符串。字符串元素被预定义并且存放在内存中，其起始内存位置有便签 output指示。 .ascii和.asciz的区别是，.asciz会在字符串后自动添加结束符\\0.    字符串部分逆置  考察字符串的输入输出  注意字符串在输入的时候有两个参数，第一个$ $a_0$存储字符串的首地址，第二个$$a_1$存储字符串的长度$+1$（因为字符串末尾需要有一个$NULL(\u0026rsquo;\\setminus0\u0026rsquo;)$）   考察对字符的操作，存取分别用$sb、lb$  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  .data mystring: .space 1010 .text # 读入零散数据 li $v0, 5 syscall move $t0, $v0 #读入n li $v0, 5 syscall move $t1, $v0 #读入x li $v0, 5 syscall move $t2, $v0 #读入y # 读入字符串 li $v0, 8 la $a0, mystring addi $a1, $t0, 1 syscall # 输出x前的字符串 li $t3, 0 loop1: bge $t3, $t1, done1 li $v0, 11 lb $a0, mystring($t3) syscall addi $t3, $t3, 1 j loop1 done1: # 反转输出x~y的字符串 addi $t3, $t2, 0 loop2: blt $t3, $t1, done2 li $v0, 11 lb $a0, mystring($t3) syscall addi $t3, $t3, -1 j loop2 done2: # 输出y后的字符串 addi $t3, $t2, 1 loop3: bge $t3, $t0, done3 li $v0, 11 lb $a0, mystring($t3) syscall addi $t3, $t3, 1 j loop3 done3: li $v0, 10 syscall   冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  .data array: .word 0:101 .text main: # 读入数据 li $v0, 5 syscall move $s0, $v0 # 循环读入数组 li $t0, 0 for1: bge $t0, $s0, break1 mul $t1, $t0, 4 li $v0, 5 syscall sw $v0, array($t1) addi $t0, $t0, 1 j for1 break1: # 排序 li $t0, 0 #i指针 for2: bge $t0, $s0, break2 li $t1, 0 #j指针 addi $t2, $s0, -1 sub $t2, $t2, $t0 for3: bge $t1, $t2, break3 # j与j+1的地址 mul $t4, $t1, 4 addi $t5, $t4, 4 lw $s4, array($t4) lw $s5, array($t5) ble $s4, $s5, L sw $s5, array($t4) sw $s4, array($t5) L: addi $t1, $t1, 1 j for3 break3: addi $t0, $t0, 1 j for2 break2: li $t0, 0 for4: bge $t0, $s0, break4 mul $t1, $t0, 4 lw $a0, array($t1) li $v0, 1 syscall addi $t0, $t0, 1 j for4 break4: li $v0, 10 syscall    数组的应用 函数的调用以及地址返回 在mips中使用递归函数（用栈指针模拟$sp）  递归函数 递归的基本例 有关指令 1  jal function #set $ra to Program Counter(PC),then jump to statement at target addres   C语言代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026lt;stdio.h\u0026gt; int factorial(int n); int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int res = factorial(n); printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } int factorial(int n) { if (n \u0026lt; 1) return 1; else return n * factorial(n - 1); }   MIPS代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  .data prompt1: .asciiz \u0026#34;Enter the number\\n\u0026#34; prompt2: .asciiz \u0026#34;The factorial of n is:\\n\u0026#34; .text # Print prompt1 li $v0, 4 la $a0, prompt1 syscall # Read integer li $v0, 5 syscall #Call factorial move $a0, $v0 jal factorial move $a1, $v0 # save return value to a # Print prompt2 li $v0, 4 la $a0, prompt2 syscall # Print result li $v0, 1 move $a0, $a1 syscall # Exit li $v0, 10 syscall ## Function int factorial(int n) factorial: ## YOUR CODE HERE addi $sp,$sp,-8 #adjust stack for 2 items sw $ra,4($sp) #save return address sw $a0,0($sp) #save the argument n slti $t0,$a0,1 #if n \u0026lt; 1,then set $t0 as 1 beq $t0,$zero,L1 #if equal,then jump L1 #above all,if n \u0026gt;= 1,then jump L1 #if(n \u0026lt; 1) addi $v0,$zero,1 #return 1 addi $sp,$sp,8 #pop 2 items off stack jr $ra #return to caller #else L1: add $a0,$a0,-1 #argument :n - 1 jal factorial #call factorial with (n-1) lw $a0,0($sp) #restore argument n lw $ra,4($sp) #restore address addi $sp,$sp,8 #adjust stack pionter mul $v0,$a0,$v0 #return n * factorial(n-1) jr $ra #return to caller ## END OF YOUR CODE #jr $ra   快排  栈指针，存储$ra以及每次快排的区间i，j 函数调用，$ra与jal绑定用以递归回溯  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148  .data array: .space 4040 comma: .ascii \u0026#34;,\\0\u0026#34; bracket2: .ascii \u0026#34;]\\0\u0026#34; bracket1: .ascii \u0026#34;[\\0\u0026#34; .text init: # 读入n的值 li $v0, 5 syscall move $s0, $v0 # 读入数组值的指针，$t0 addi $t0, $zero, 0 mul $s0, $s0, 4 input: beq $t0, $s0, input_end # 读入第i个值 li $v0, 5 syscall # 存至当前指针处 sw $v0, array($t0) addi $t0, $t0, 4 j input input_end: addi $s3, $zero, 0 addi $s4, $t0, -4 add $sp, $sp, -12 sw $s4, 0($sp) sw $s3, 4($sp) jal quick_sort li $v0, 4 la $a0, bracket1 syscall addi $t0, $zero, 0 output: #输出结果 li $v0, 1 lw $a0, array($t0) syscall add $t0, $t0, 4 beq $t0, $s0, outputend li $v0, 4 la $a0, comma syscall j output outputend: li $v0, 4 la $a0, bracket2 syscall addi $t0, $zero, 0 # 结束程序 li $v0, 10 syscall # 快排算法 quick_sort: # $s3为i，$s4为j lw $s4, 0($sp) lw $s3, 4($sp) sw $ra, 8($sp) bge $s3, $s4, L1 # 当i\u0026gt;=j时，跳出循环 # else j getstandard li $v0, 4 addi $a0, $s5, 0 syscall L: #递归调用排序 addi $sp, $sp, -24 sw $ra, 20($sp) addi $s6, $s6, -4 sw $s3, 16($sp) sw $s6, 12($sp) sw $ra, 8($sp) addi $s6, $s6, 8 sw $s6, 4($sp) sw $s4, 0($sp) jal quick_sort jal quick_sort lw $ra, 8($sp) addi $sp, $sp, 12 jr $ra L1: addi $sp, $sp, 12 jr $ra getstandard: lw $t3, array($s3) #key addi $s6, $s3, 0 #i指针备份 addi $s7, $s4, 0 #j指针备份 while2: bge $s6, $s7, end2 while3: bge $s6, $s7, end3 lw $t2, array($s7) blt $t2, $t3, end3 addi $s7, $s7, -4 j while3 end3: bge $s6, $s7, while4 lw $t2, array($s7) sw $t2, array($s6) while4: bge $s6, $s7, end4 lw $t2, array($s6) bgt $t2, $t3, end4 addi $s6, $s6, 4 j while4 end4: bge $s6, $s7, while2 lw $t2, array($s6) sw $t2, array($s7) j while2 end2: sw $t3, array($s6) j L   区分lb，lh，lw，分别是加载字节，半字以及字\n 一个字节（byte）有8位（bits） 半字是半个字，16位，2个字节 一个字是32位，有4个字节  同理可以区分sb，sh，sw\n延迟槽\n汉诺塔 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  .data s1: .ascii \u0026#34;-\u0026gt;\\0\u0026#34; line: .ascii \u0026#34;\\n\\0\u0026#34; A: .ascii \u0026#34;A\\0\u0026#34; B: .ascii \u0026#34;B\\0\u0026#34; C: .ascii \u0026#34;C\\0\u0026#34; .text # 读入n li $v0, 5 syscall move $s0, $v0 la $s1, A la $s2, B la $s3, C jal hannuo li $v0, 10 syscall # 汉诺塔函数 hannuo: addi $sp, $sp, -20 sw $ra, 0($sp) sw $s0, 4($sp) #存储n sw $s1, 8($sp) #存储盘子A sw $s2, 12($sp)\t#存储盘子B sw $s3, 16($sp) #存储盘子C beq $s0, 1, move lw $s0, 4($sp) addi $s0, $s0, -1 lw $s1, 8($sp) lw $s2, 16($sp) lw $s3, 12($sp) jal hannuo lw $s1, 8($sp) lw $s3, 16($sp) jal move lw $s0, 4($sp) addi $s0, $s0, -1 lw $s1, 12($sp) lw $s2, 8($sp) lw $s3, 16($sp) jal hannuo # 跳转回上一次递归 lw $ra, 0($sp) addi $sp, $sp, 20 jr $ra move: li $v0, 4 move $a0, $s1 syscall li $v0, 4 la $a0, s1 syscall li $v0, 4 move $a0, $s3 syscall li $v0, 4 la $a0, line syscall lw $s0, 4($sp) beq $s0, 1, L1 jr $ra L1: lw $ra, 0($sp) addi $sp, $sp, 20 jr $ra   ","permalink":"http://appletea233.github.io/myblog_hogo/posts/blog/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/","summary":"基础知识 寄存器 基础操作 系统调用 GCD最大公约数 主要考察循环，使用$j$指令进行代码块间的跳转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24","title":"MIPS汇编基础"},{"content":"函数调用关系 结构体信息 Page 1 2 3 4 5 6 7 8 9  struct Page_list{ struct { struct { struct Page *le_next; struct Page le_prev; } pp_link; u_short pp_ref; }* lh_first; // Page* }    Env_list结构与之类似  Trapframe 1 2 3 4 5 6 7 8 9 10 11 12 13  struct Trapframe { //lr:need to be modified(reference to linux pt_regs) TODO \t/* Saved main processor registers. */ unsigned long regs[32]; /* Saved special registers. */ unsigned long cp0_status; unsigned long hi; unsigned long lo; unsigned long cp0_badvaddr; unsigned long cp0_cause; unsigned long cp0_epc; unsigned long pc; };   Env 1 2 3 4 5 6 7 8 9 10 11  struct Env { struct Trapframe env_tf; // Saved registers  LIST_ENTRY(Env) env_link; // Free LIST_ENTRY  u_int env_id; // Unique environment identifier  u_int env_parent_id; // env_id of this env\u0026#39;s parent  u_int env_status; // Status of the environment  Pde *env_pgdir; // Kernel virtual address of page dir  u_int env_cr3; LIST_ENTRY(Env) env_sched_link; u_int env_pri; };    env_status : 该变量只能有以下三种取值：   ENV_FREE : 表明该进程是不活动的，即该进程控制块处于进程空闲链表中。 ENV_NOT_RUNNABLE : 表明该进程处于阻塞状态，处于该状态的进程需要在一定条件下变成就绪状态从而被CPU调度。（比如因进程通信阻塞时变为 ENV_NOT_RUNNABLE，收到信息后变回 ENV_RUNNABLE） ENV_RUNNABLE : 表明该进程处于执行状态或就绪状态，即其可能是正在运行的，也可能正在等待被调度。  Ehdr与Phdr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  typedef struct { unsigned char\te_ident[EI_NIDENT];\t/* Magic number and other info */ Elf32_Half\te_type;\t/* Object file type */ Elf32_Half\te_machine;\t/* Architecture */ Elf32_Word\te_version;\t/* Object file version */ Elf32_Addr\te_entry;\t/* Entry point virtual address */ Elf32_Off\te_phoff;\t/* Program header table file offset */ Elf32_Off\te_shoff;\t/* Section header table file offset */ Elf32_Word\te_flags;\t/* Processor-specific flags */ Elf32_Half\te_ehsize;\t/* ELF header size in bytes */ Elf32_Half\te_phentsize;\t/* Program header table entry size */ Elf32_Half\te_phnum;\t/* Program header table entry count */ Elf32_Half\te_shentsize;\t/* Section header table entry size */ Elf32_Half\te_shnum;\t/* Section header table entry count */ Elf32_Half\te_shstrndx;\t/* Section header string table index */ } Elf32_Ehdr;   1 2 3 4 5 6 7 8 9 10  typedef struct { Elf32_Word\tp_type;\t/* Segment type */ Elf32_Off\tp_offset;\t/* Segment file offset */ Elf32_Addr\tp_vaddr;\t/* Segment virtual address */ Elf32_Addr\tp_paddr;\t/* Segment physical address */ Elf32_Word\tp_filesz;\t/* Segment size in file */ Elf32_Word\tp_memsz;\t/* Segment size in memory */ Elf32_Word\tp_flags;\t/* Segment flags */ Elf32_Word\tp_align;\t/* Segment alignment */ } Elf32_Phdr;   一些全局变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  // env.h ./include/env.h:11:#define LOG2NENV 10 ./include/env.h:12:#define NENV (1\u0026lt;\u0026lt;LOG2NENV) ./include/env.h:13:#define ENVX(envid) ((envid) \u0026amp; (NENV - 1)) // env.c struct Env *envs = NULL; // All environments struct Env *curenv = NULL; // the current env  static struct Env_list env_free_list; // Free list struct Env_list env_sched_list[2]; // Runnable list  extern Pde *boot_pgdir; extern char *KERNEL_SP; static u_int asid_bitmap[2] = {0}; // 64  // mmu.c ./include/error.h:8:#define E_BAD_ENV 2 // Environment doesn\u0026#39;t exist or otherwise ./include/mmu.h:109:#define E_BAD_ENV 2 // Environment doesn\u0026#39;t exist or otherwise  // page相关 #define BY2PG\t4096\t// bytes to a page #define PDMAP\t(4*1024*1024)\t// bytes mapped by a page directory entry #define PGSHIFT\t12 #define PDSHIFT\t22\t// log2(PDMAP) #define PDX(va)\t((((u_long)(va))\u0026gt;\u0026gt;22) \u0026amp; 0x03FF) // 取页目录序号 #define PTX(va)\t((((u_long)(va))\u0026gt;\u0026gt;12) \u0026amp; 0x03FF) // 取...序号 #define PTE_ADDR(pte)\t((u_long)(pte)\u0026amp;~0xFFF)  // page number field of address #define PPN(va)\t(((u_long)(va))\u0026gt;\u0026gt;12) #define VPN(va)\tPPN(va)  #define VA2PFN(va)\t(((u_long)(va)) \u0026amp; 0xFFFFF000 ) // va 2 PFN for EntryLo0/1 #define PTE2PT\t1024  // 内存地图 #define KERNBASE 0x80010000  #define VPT (ULIM + PDMAP ) #define KSTACKTOP (VPT-0x100) #define KSTKSIZE (8*BY2PG) #define ULIM 0x80000000\t #define UVPT (ULIM - PDMAP) #define UPAGES (UVPT - PDMAP) #define UENVS (UPAGES - PDMAP) #define UTOP UENVS  #define UXSTACKTOP (UTOP) #define TIMESTACK 0x82000000  #define PTE_ADDR(pte) ((u_long)(pte)\u0026amp;~0xFFF)   0x00400000\n变量转换  page2ppn page2pa page2kva：将页转换为内核的虚拟地址 va2pa  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  LIST_HEAD(Page_list, Page); typedef LIST_ENTRY(Page) Page_LIST_entry_t; struct Page { Page_LIST_entry_t pp_link;\t/* free list link */ // Ref is the count of pointers (usually in page table entries) \t// to this page. This only holds for pages allocated using \t// page_alloc. Pages allocated at boot time using pmap.c\u0026#39;s \u0026#34;alloc\u0026#34; \t// do not have valid reference count fields.  u_short pp_ref; }; extern struct Page *pages; static inline u_long page2ppn(struct Page *pp) { return pp - pages; } static inline u_long page2pa(struct Page *pp) { return page2ppn(pp)\u0026lt;\u0026lt;PGSHIFT; } static inline struct Page * pa2page(u_long pa) { if (PPN(pa) \u0026gt;= npage) panic(\u0026#34;pa2page called with invalid pa: %x\u0026#34;, pa); return \u0026amp;pages[PPN(pa)]; } static inline u_long page2kva(struct Page *pp) { return KADDR(page2pa(pp)); } static inline u_long va2pa(Pde *pgdir, u_long va) { Pte *p; pgdir = \u0026amp;pgdir[PDX(va)]; if (!(*pgdir\u0026amp;PTE_V)) return ~0; p = (Pte*)KADDR(PTE_ADDR(*pgdir)); if (!(p[PTX(va)]\u0026amp;PTE_V)) return ~0; return PTE_ADDR(p[PTX(va)]); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #define ULIM 0x80000000 #define PADDR(kva)\t\\ ({\t\\ u_long a = (u_long) (kva);\t\\ if (a \u0026lt; ULIM)\t\\ panic(\u0026#34;PADDR called with invalid kva %08lx\u0026#34;, a);\\ a - ULIM;\t\\ })  // translates from physical address to kernel virtual address #define KADDR(pa)\t\\ ({\t\\ u_long ppn = PPN(pa);\t\\ if (ppn \u0026gt;= npage)\t\\ panic(\u0026#34;KADDR called with invalid pa %08lx\u0026#34;, (u_long)pa);\\ (pa) + ULIM;\t\\ })   Exercise exercise 3.1  使用boot_map_segment进行段映射，envs 数组应该被UENVS 区域映射  exercise 3.2  使用envs函数，注意queue.h函数调用的参数类型。 插入顺序为倒序  exercise 3.3 关于asid_alloc函数 asid_alloc 函数，这个函数的作用是为新创建的进程分配一个异于当前所有未被释放的进程的 ASID。\n  这个 ASID是什么？\n  为什么要与其他的进程不同呢？\n  根据 lab2 的学习我们得知进程是通过页表来访问内存的，而不同的进程的同一个虚拟地址可能会映射到不同的物理地址。\n为了实现这个功能，TLB 中除了存储页表的映射信息之外，还会存储进程的标识编号，作为 Key 的一部分，用于保证查到的页面映射属于当前进程，而这个编号就是ASID。显然，不同进程的虚拟地址是可以对应相同 VPN 的，而如果 ASID 也不具备唯一标识性，就与 TLB Field 的唯一性要求相矛盾了。因此，直到进程被销毁或 TLB 被清空时，才可以把这个 ASID 分配给其他进程。\n 为什么不能简单的通过自增来避免冲突呢？  简单的回答：用来存储ASID的位数有限，自增容易发生溢出\nexercise 3.4 env_setup_vm 1 2 3 4 5 6 7 8 9  static int env_setup_vm(struct Env *e); for (i = 0; i \u0026lt; PDX(UTOP); i++){ pgdir[i] = 0; } for (i = PDX(UTOP); i\u0026lt;PTE2PT; i++){ if (i != PDX(VPT) \u0026amp;\u0026amp; i != PDX(UVPT)) pgdir[i] = boot_pgdir[i]; }    很多疑问 关于boot_pgdir  exercise 3.5 env_alloc 1 2  // 设置sp寄存器 e-\u0026gt;env_tf.regs[29] = USTACKTOP;   exercise 3.6 load_icode_mapper\t 调用链：load_icode -\u0026gt; load_elf -\u0026gt; load_icode_mapper\nexercise 3.7 load_elf和load_icode exercise 3.8 env_create 和env_create_priority 调用链：env_create -\u0026gt; env_create_priority\nexercise 3.9 mips_init exercise 3.10 env_run exercise 3.11 page_init Thinking Thinking 3.1 思考envid2env 函数:\n为什么envid2env 中需要判断e-\u0026gt;env_id != envid 的情况？如果没有这步判断会发生什么情况？\n envid可能大于64 没有这一步可能导致非内存控制快的内存地址被转换  Thinking 3.2 结合include/mmu.h 中的地址空间布局，思考env_setup_vm 函数：\n UTOP 和ULIM 的含义分别是什么，UTOP 和ULIM 之间的区域与UTOP以下的区域相比有什么区别？   ULIM以上是内核态 UTOP与ULIM之间有三个页表 ULIM之下的是栈，UTOP和ULIM之间的区域是页表   请结合系统自映射机制解释代码中pgdir[PDX(UVPT)]=env_cr3的含义。  自身映射到自身\n 谈谈自己对进程中物理地址和虚拟地址的理解。  之间有映射关系。\nThinking 3.3 找到 user_data 这一参数的来源，思考它的作用。没有这个参数可不可以？为什么？（可以尝试说明实际的应用场景，举一个实际的库中的例子）\n 为load_icode_mapper传参  Thinking 3.4 结合load_icode_mapper 的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？\n va不与页对其 va+binsize不与页面对齐  Thinking 3.5 思考上面这一段话，并根据自己在lab2 中的理解，回答：\n 你认为这里的 env_tf.pc 存储的是物理地址还是虚拟地址?  是虚拟地址\n 你觉得entry_point其值对于每个进程是否一样？该如何理解这种统一或不同  不一定相同，对不同的elf文件entry_point不同。\nThinking 3.6 请查阅相关资料解释，上面提到的epc是什么？为什么要将env_tf.pc设置为epc呢？\nThinking 3.7 关于 TIMESTACK，请思考以下问题：\n 操作系统在何时将什么内容存到了 TIMESTACK 区域 TIMESTACK 和 env_asm.S 中所定义的 KERNEL_SP 的含义有何不同  Thinking 3.8 试找出上述 5 个异常处理函数的具体实现位置。\n   异常号 处理函数 含义 具体实现位置 备注     0 handle_int 表示中断，由时钟中断、控制台中断等中断造成 ./lib/genex.S    1 handle_mod 表示存储异常，进行存储操作时该页被标记为只读 ./lib/genex.S    2 handle_tlb TLB 异常，TLB 中没有和程序地址匹配的有效入口 ./lib/genex.S    3 handle_tlb TLB 异常，TLB 失效，且未处于异常模式（用于提高处理效率） ./lib/genex.S    8 handle_sys 系统调用，陷入内核，执行了 syscall 指令 ./lib/syscall.S     Thinking 3.9 阅读 kclock_asm.S 和 genex.S 两个文件，并尝试说出 set_timer 和timer_irq 函数中每行汇编代码的作用\nset_timer 1 2 3 4 5 6 7 8 9 10  LEAF(set_timer) li t0, 0xc8 sb t0, 0xb5000100\t// 向0xb5000100 位置写入0xc8 sw\tsp, KERNEL_SP\t// 将当前栈指针保存到KERNEL_SP setup_c0_status STATUS_CU0|0x1001 0\t// 调用setup_c0_status函数 jr ra nop END(set_timer)   time_irq 1 2 3 4 5 6 7 8 9 10 11 12 13  timer_irq: sb zero, 0xb5000110\t// 在0xb5000110写入0 1:\tj\tsched_yield\t// 跳转到sched_ yield nop /*li t1, 0xff lw t0, delay addu t0, 1 sw\tt0, delay beq\tt0,t1,1f\tnop*/ j\tret_from_exception\tnop   要产生时钟中断，我们不仅要了解中断的产生与处理，还要了解 gxemul 是如何模拟时钟中断的。kclock_init 函数完成了时钟的初始化，该函数主要调用 set_timer 函数，完成如下操作：\n 首先向0xb5000100 位置写入0xc8，其中0xb5000000 是模拟器(gxemul) 映射实时钟的位置。偏移量为0x100 表示来设置实时钟中断的频率，0xc8 则表示1 秒钟中断200次，如果写入0，表示关闭实时钟。实时钟对于R3000 来说绑定到了4 号中断上，故这段代码其实主要用来触发了4 号中断。注意这里的中断号和异常号是不一样的概念，我们实验的异常包括中断。 一旦实时钟中断产生，就会触发MIPS 中断，从而MIPS 将PC 指向0x80000080，从而跳转到.text.exc_vec3代码段执行。对于实时钟引起的中断，通过.text.exc_vec3代码段的分发，最终会调用handle_ int 函数来处理实时钟中断。 在handle_ int 判断CP0_CAUSE寄存器是不是对应的4 号中断位引发的中断，如果是，则执行中断服务函数timer_ irq。 在timer_ irq 里直接跳转到sched_ yield 中执行。而这个函数就是我们将要补充的调度函数。  SAVE_ALL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  .macro SAVE_ALL // 前四行其首先取出了 SR 寄存器的值, 然后利用移位等操作判断第 28 位的值, 根据前面的讲述我们可以知道, 也即判断当前是否处于用户模式下。5 mfc0\tk0,CP0_STATUS sll\tk0,3 /* extract cu0 bit */ bltz\tk0,1f nop /* * Called from user mode, new stack */ // lui\tk1,%hi(kernelsp) // lw\tk1,%lo(kernelsp)(k1) //not clear right now // 接下来将当前运行栈的地址保存到 k0 中；然后调用 get_sp 宏，根据中断异常的种类判断需要保存的位置，并分配一定的空间；将之前的运行栈地址与 2 号寄存器 $v0 先保存起来，便于后面可以放心的使用 sp 寄存器与 v0 寄存器。 1: move\tk0,sp get_sp move\tk1,sp subu\tsp,k1,TF_SIZE sw\tk0,TF_REG29(sp) sw\t$2,TF_REG2(sp) mfc0\tv0,CP0_STATUS sw\tv0,TF_STATUS(sp) mfc0\tv0,CP0_CAUSE sw\tv0,TF_CAUSE(sp) mfc0\tv0,CP0_EPC sw\tv0,TF_EPC(sp) mfc0\tv0, CP0_BADVADDR sw\tv0, TF_BADVADDR(sp) mfhi\tv0 sw\tv0,TF_HI(sp) mflo\tv0 sw\tv0,TF_LO(sp) sw\t$0,TF_REG0(sp) sw\t$1,TF_REG1(sp) //sw\t$2,TF_REG2(sp) sw\t$3,TF_REG3(sp) sw\t$4,TF_REG4(sp) sw\t$5,TF_REG5(sp) sw\t$6,TF_REG6(sp) sw\t$7,TF_REG7(sp) sw\t$8,TF_REG8(sp) sw\t$9,TF_REG9(sp) sw\t$10,TF_REG10(sp) sw\t$11,TF_REG11(sp) sw\t$12,TF_REG12(sp) sw\t$13,TF_REG13(sp) sw\t$14,TF_REG14(sp) sw\t$15,TF_REG15(sp) sw\t$16,TF_REG16(sp) sw\t$17,TF_REG17(sp) sw\t$18,TF_REG18(sp) sw\t$19,TF_REG19(sp) sw\t$20,TF_REG20(sp) sw\t$21,TF_REG21(sp) sw\t$22,TF_REG22(sp) sw\t$23,TF_REG23(sp) sw\t$24,TF_REG24(sp) sw\t$25,TF_REG25(sp) sw\t$26,TF_REG26(sp) sw\t$27,TF_REG27(sp) sw\t$28,TF_REG28(sp) sw\t$30,TF_REG30(sp) sw\t$31,TF_REG31(sp) .endm   内存地图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  /* o 4G -----------\u0026gt; +----------------------------+------------0x100000000 o | ... | kseg3 o +----------------------------+------------0xe000 0000 o | ... | kseg2 o +----------------------------+------------0xc000 0000 o | Interrupts \u0026amp; Exception | kseg1 o +----------------------------+------------0xa000 0000 o | Invalid memory | /|\\ o +----------------------------+----|-------Physics Memory Max o | ... | kseg0 o VPT,KSTACKTOP-----\u0026gt; +----------------------------+----|-------0x8040 0000-------end o | Kernel Stack | | KSTKSIZE /|\\ o +----------------------------+----|------ | o | Kernel Text | | PDMAP o KERNBASE -----\u0026gt; +----------------------------+----|-------0x8001 0000 | o | Interrupts \u0026amp; Exception | \\|/ \\|/ o ULIM -----\u0026gt; +----------------------------+------------0x8000 0000------- o | User VPT | PDMAP /|\\ o UVPT -----\u0026gt; +----------------------------+------------0x7fc0 0000 | o | PAGES | PDMAP | o UPAGES -----\u0026gt; +----------------------------+------------0x7f80 0000 | o | ENVS | PDMAP | o UTOP,UENVS -----\u0026gt; +----------------------------+------------0x7f40 0000 | o UXSTACKTOP -/ | user exception stack | BY2PG | o +----------------------------+------------0x7f3f f000 | o | Invalid memory | BY2PG | o USTACKTOP ----\u0026gt; +----------------------------+------------0x7f3f e000 | o | normal user stack | BY2PG | o +----------------------------+------------0x7f3f d000 | a | | | a ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ | a . . | a . . kuseg a . . | a |~~~~~~~~~~~~~~~~~~~~~~~~~~~~| | a | | | o UTEXT -----\u0026gt; +----------------------------+ | o | | 2 * PDMAP \\|/ a 0 ------------\u0026gt; +----------------------------+ ----------------------------- o */    boot_pgdir 被映射到UPAGES envs被映射到UENVS  04000000\n异常与中断 我们实验里认为凡是引起控制流突变的都叫做异常，而中断仅仅是异常的一种，并且是仅有的一种异步异常。\n异常的产生与返回 ","permalink":"http://appletea233.github.io/myblog_hogo/posts/blog/%E6%96%87%E6%A1%A3/","summary":"函数调用关系 结构体信息 Page 1 2 3 4 5 6 7 8 9 struct Page_list{ struct { struct { struct Page *le_next; struct Page le_prev; } pp_link; u_short pp_ref; }* lh_first; // Page* } Env_list结构与之类似 Trapframe 1 2 3 4 5 6 7 8 9 10 11 12 13","title":"BUAA操作系统lab3笔记"},{"content":"hhhhh 我的第一篇博客\nhhhhhhh 1  printf(\u0026#34;hello world\u0026#34;);   ","permalink":"http://appletea233.github.io/myblog_hogo/posts/blog/my-first-post/","summary":"hhhhh 我的第一篇博客 hhhhhhh 1 printf(\u0026#34;hello world\u0026#34;);","title":"My First Post"},{"content":"","permalink":"http://appletea233.github.io/myblog_hogo/tags/","summary":"","title":"🔖标签"},{"content":"","permalink":"http://appletea233.github.io/myblog_hogo/about/","summary":"","title":"🙋🏻‍♂️关于"},{"content":" Appletea\u0026#39;s Blog 一个记录学习、生活的博客     Appletea\u0026#39;s Blog 一个记录学习、生活的博客    ","permalink":"http://appletea233.github.io/myblog_hogo/links/","summary":"Appletea\u0026#39;s Blog 一个记录学习、生活的博客 Appletea\u0026#39;s Blog 一个记录学习、生活的博客","title":"🤝友链"}]