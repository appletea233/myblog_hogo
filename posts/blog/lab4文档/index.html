<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=robots content="index, follow"><title>BUAA操作系统lab4笔记 | Appletea's Blog</title><meta name=keywords content="study,os"><meta name=description content="如题"><meta name=author content="
作者:&nbsp;Appletea"><link rel=canonical href=http://appletea233.github.io/myblog_hogo/posts/blog/lab4%E6%96%87%E6%A1%A3/><link crossorigin=anonymous href=/myblog_hogo/assets/css/stylesheet.min.dafbad219c160a2cdb650c1eb791a4a2416f32636655e6cfe0792b9e36128edc.css integrity="sha256-2vutIZwWCizbZQwet5GkokFvMmNmVebP4HkrnjYSjtw=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/myblog_hogo/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://appletea233.github.io/myblog_hogo/img/Q.jpg><link rel=icon type=image/png sizes=16x16 href=http://appletea233.github.io/myblog_hogo/img/Q.jpg><link rel=icon type=image/png sizes=32x32 href=http://appletea233.github.io/myblog_hogo/img/Q.jpg><link rel=apple-touch-icon href=http://appletea233.github.io/myblog_hogo/Q.jpg><link rel=mask-icon href=http://appletea233.github.io/myblog_hogo/Q.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="BUAA操作系统lab4笔记"><meta property="og:description" content="如题"><meta property="og:type" content="article"><meta property="og:url" content="http://appletea233.github.io/myblog_hogo/posts/blog/lab4%E6%96%87%E6%A1%A3/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-19T01:00:03+08:00"><meta property="article:modified_time" content="2022-05-19T01:00:03+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="BUAA操作系统lab4笔记"><meta name=twitter:description content="如题"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"📚文章","item":"http://appletea233.github.io/myblog_hogo/posts/"},{"@type":"ListItem","position":3,"name":"Blog","item":"http://appletea233.github.io/myblog_hogo/posts/blog/"},{"@type":"ListItem","position":4,"name":"BUAA操作系统lab4笔记","item":"http://appletea233.github.io/myblog_hogo/posts/blog/lab4%E6%96%87%E6%A1%A3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"BUAA操作系统lab4笔记","name":"BUAA操作系统lab4笔记","description":"如题","keywords":["study","os"],"articleBody":"实验目的 掌握系统调用的概念及流程 实现进程间通讯机制 实现 fork 函数 掌握页写入异常的处理流程 系统和调用 系统调用的概念：\n在用户态下，用户进程不能访问系统的内核空间，也就是说它不能存取内核使用的内存数据，也不能调用内核函数， 这一点是由CPU的硬件结构保证的。然而，用户进程在特定的场景下往往需要执行一些只能由内核完成的操作，如 操作硬件、动态分配内存，以及与其他进程进行通信等。允许在内核态执行用户程序提供的代码显然是不安全的，因此操作系统设计了一系列内核空间 中的函数，==当用户进程需要进行这些操作时，会引发特定的异常以陷入内核态，由内核调用对应的函数==，从而安全地为用户进程提供受限的系统级操作， 我们把这种机制称为系统调用。\n在 lab4 中，我们需要实现上述的系统调用机制，并在此基础上实现进程间通信（IPC）机制和一个重要的进程创建机制 fork。 在fork部分的实验中，我们会介绍一种被称为写时复制（COW）的特性，以及与其相关的页写入异常处理。\n用户态和内核态（也称用户模式和内核模式）：\n它们是 CPU 运行的两种状态。根据 lab3 的说明，在 MOS 操作系统实验使用的仿真 R3000 CPU 中，该状态由 CP0 SR 寄存器中 KUc 位的值标志。\n用户空间和内核空间\n它们是虚拟内存（进程的地址空间）中的两部分区域。根据 lab2 的说明，MOS 中的用户空间包括 kuseg， 而内核空间主要包括 kseg0 和 kseg1。每个进程的用户空间通常通过页表映射到不同的物理页，而内核空间则直接映射到固定的物理页1以及外部硬件设备。 CPU 在内核态下可以访问任何内存区域，对物理内存等硬件设备有完整的控制权，而在用户态下则只能访问用户空间。\n（用户）进程和内核\n进程是资源分配与调度的基本单位，拥有独立的地址空间，而内核负责管理系统资源和调度进程，使进程能够并发运行。 与前两对概念不同，进程和内核并不是对立的存在，可以认为内核是存在于所有进程地址空间中的一段代码。\n设置*env_tf.cp0_status 的值为 0x1000100c*\n系统调用：于直接使用这些系统调用较为麻烦，于是产生了一系列用户空间的API定义，如POSIX 和C标准库等，它们在系统调用的基础上， 实现更多更高级的常用功能，使得用户在编写程序时不用再处理这些繁琐而复杂的底层操作， 而是直接通过调用高层次的API就能实现各种功能。通过这样巧妙的层次划分，使得程序更为灵活，也具有了更好的可移植性。 对于用户程序来说，只要自己所依赖的API不变，无论底层的系统调用如何变化，都不会对自己造成影响， 更易于在不同的系统间移植。整个结构如下表所示。\n系统调用机制的实现：\nsyscall_*的函数的实现中，它们毫无例外都调用了msyscall函数，而且函数的第一个参数都是一个与调用名相似的宏（如SYS_putchar）， 在我们的MOS操作系统实验中把这个参数称为系统调用号（请在代码中找到这个宏的定义位置，了解系统调用号的排布规则）：\n系统调用号查看：./include/unistd.h: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #ifndef UNISTD_H #define UNISTD_H #define __SYSCALL_BASE 9527 #define __NR_SYSCALLS 20 #define SYS_putchar ((__SYSCALL_BASE ) + (0 ) ) #define SYS_getenvid ((__SYSCALL_BASE ) + (1 ) ) #define SYS_yield\t((__SYSCALL_BASE ) + (2 ) ) #define SYS_env_destroy\t((__SYSCALL_BASE ) + (3 ) ) #define SYS_set_pgfault_handler\t((__SYSCALL_BASE ) + (4 ) ) #define SYS_mem_alloc\t((__SYSCALL_BASE ) + (5 ) ) #define SYS_mem_map\t((__SYSCALL_BASE ) + (6 ) ) #define SYS_mem_unmap\t((__SYSCALL_BASE ) + (7 ) ) #define SYS_env_alloc\t((__SYSCALL_BASE ) + (8 ) ) #define SYS_set_env_status\t((__SYSCALL_BASE ) + (9 ) ) #define SYS_set_trapframe\t((__SYSCALL_BASE ) + (10 ) ) #define SYS_panic\t((__SYSCALL_BASE ) + (11 ) ) #define SYS_ipc_can_send\t((__SYSCALL_BASE ) + (12 ) ) #define SYS_ipc_recv\t((__SYSCALL_BASE ) + (13 ) ) #define SYS_cgetc\t((__SYSCALL_BASE ) + (14 ) ) #endif 练习题 由于网站中无法提交答案，因此在这里简记一下\n对于系统调用syscall_cgetc，它传入msyscall函数的系统调用号的数字值应该是： 9527+14 = 9541\n阅读代码，如果想要增加一个系统调用，下面这些文件需要被修改：\nlib/syscall.S（系统调用列表sys_call_table）、include/unistd.h（系统调用号相关）、lib/syscall_all.c（内核态系统调用函数）、user/syscall_lib.c（用户态系统调用函数syscall_*()） 在汇编宏CLI中，用到的STATUS_CU0的值是: 0x10000000(在./include/asm/cp0regdef.h:41处定义)\nlib/syscall.S中最后一个TODO：/* TODO: 恢复栈指针到分配前的状态*/的正确代码是：addiu sp, sp, 24\n用于从异常中返回（恢复现场）的ret_from_exception宏的定义在这个文件中：/lib/genex.S:32\n1 2 3 4 5 6 7 8 9 10 11 FEXPORT(ret_from_exception) .set noat .set noreorder RESTORE_SOME\t/* 定义于./include/stackframe.h:90 */ .set at lw\tk0,TF_EPC(sp)\t/* 取出用户态当前地址 */ lw\tsp,TF_REG29(sp) /* Deallocate stack */ //1:\tj\t1b nop jr\tk0\trfe\tlib/syscall_all.c 中实现了一些系统调用，其中用于创建一个进程的是:sys_env_alloc\n知识补充 汇编指令 汇编码 含义 mfc0 t, cs 把32位数据从协处理寄存器cs传送到通用寄存器t mtc0 s, cs 把32位数据从通用寄存器s传送到协处理寄存器cs 回顾指令\n汇编码 含义 sll d, s, shf d = s \u003c\u003c shf 进程间通讯机制 字段 含义 env_ipc_value 进程传递的具体数值 env_ipc_from 发送方的进程ID env_ipc_recving 1：等待接受数据中；0：不可接受数据 env_ipc_dstva 接收到的页面需要与自身的哪个虚拟页面完成映射 env_ipc_perm 传递的页面的权限位设置 练习题 由于网站中无法提交答案，因此在这里简记一下\n进程控制块中用于表示进程是否处于接收状态的域是env_ipc_recving，（例如，env_ipc_value）如果处于接受状态，这个域的值是1\n系统调用sys_ipc_recv中放弃CPU时，需要调用相关函数重新进行调度，请问这个相关函数是sys_yield\nFork 写入异常的处理流程 Thinking Thinking 4.1. 思考并回答下面的问题：\n内核在保存现场的时候是如何避免破坏通用寄存器的？ 使用SAVE_ALL函数用于保存所有寄存器、使用CLI函数用于屏蔽中断位的设置\n系统陷入内核调用后可以直接从当时的$a0-$a3参数寄存器中得到用户调用msyscall留下的信息吗？ 需要注意的是，陷入内核态的操作并不是从一个函数跳转到了另一个函数，此处的指针 $sp 是内核空间的栈指针，系统从用户态切换到内核态后，内核首先需要将原用户进程的运行现场保存到内核空间（其保存的结构与结构体struct Trapframe等同，请寻找完成这部分功能的代码实现），栈指针指向这个结构体的起始位置，因此我们正是借助这个保存的结构体来获取用户态中传递过来的值（例如：用户态下 $a0 寄存器的值保存在了当前栈下的 TF_REG4(sp)处）。\t——lab4指导书\n正如指导书中所说，陷入内核态的操作并不是从一个函数跳转到了另一个函数，故不能简单的从参数寄存器中获得值。\n我们是怎么做到让sys开头的函数“认为”我们提供了和用户调用msyscall时同样的参数的？ 从具体实现上讲，我们将内核空间中用于传参的寄存器中的值设置为了与msyscall中相同的状态，且栈帧顶的24Byte空间也设置成了与msyscall中相同的状态。\n内核处理系统调用的过程对Trapframe做了哪些更改？这种修改对应的用户态的变化是？ 按照cause寄存器的BD字段更新了TF_EPC，对应用户态返回的指令地址的变化\n为TF_REG2(sp) 赋值，对应用户态设置了函数的返回值\nThinking 4.2. 思考下面的问题，并对这个问题谈谈你的理解： 请回顾 lib/env.c 文件中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现 与 envid2env() 函数的行为进行解释。\n","wordCount":"2937","inLanguage":"en","datePublished":"2022-05-19T01:00:03+08:00","dateModified":"2022-05-19T01:00:03+08:00","author":[{"@type":"Person","name":"Appletea"}],"mainEntityOfPage":{"@type":"WebPage","@id":"http://appletea233.github.io/myblog_hogo/posts/blog/lab4%E6%96%87%E6%A1%A3/"},"publisher":{"@type":"Organization","name":"Appletea's Blog","logo":{"@type":"ImageObject","url":"http://appletea233.github.io/myblog_hogo/img/Q.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://appletea233.github.io/myblog_hogo accesskey=h title="Appletea's Blog (Alt + H)">Appletea's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://appletea233.github.io/myblog_hogo/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=http://appletea233.github.io/myblog_hogo/ title=🏠主页><span>🏠主页</span></a></li><li><a href=http://appletea233.github.io/myblog_hogo/posts title=📚文章><span>📚文章</span></a></li><li><a href=http://appletea233.github.io/myblog_hogo/archives/ title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=http://appletea233.github.io/myblog_hogo/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=http://appletea233.github.io/myblog_hogo/about title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li><li><a href=http://appletea233.github.io/myblog_hogo/links title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://appletea233.github.io/myblog_hogo>Home</a>&nbsp;»&nbsp;<a href=http://appletea233.github.io/myblog_hogo/posts/>📚文章</a>&nbsp;»&nbsp;<a href=http://appletea233.github.io/myblog_hogo/posts/blog/>Blog</a></div><h1 class=post-title>BUAA操作系统lab4笔记</h1><div class=post-description>如题</div><div class=post-meta>创建:&nbsp;<span title='2022-05-19 01:00:03 +0800 +0800'>2022-05-19</span>&nbsp;更新:&nbsp;2022-05-19&nbsp;字数:&nbsp;2937字&nbsp;时长:&nbsp;6分钟&nbsp;<br>作者:&nbsp;Appletea&nbsp;标签:
<a href=http://appletea233.github.io/myblog_hogo/tags/study>study</a>
<a href=http://appletea233.github.io/myblog_hogo/tags/os>os</a>
本文总阅读量:&nbsp<span id=busuanzi_value_page_pv></span>次</p></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%ae%9e%e9%aa%8c%e7%9b%ae%e7%9a%84 aria-label=实验目的>实验目的</a></li><li><a href=#%e7%b3%bb%e7%bb%9f%e5%92%8c%e8%b0%83%e7%94%a8 aria-label=系统和调用>系统和调用</a><ul><li><a href=#%e7%bb%83%e4%b9%a0%e9%a2%98 aria-label=练习题>练习题</a></li><li><a href=#%e7%9f%a5%e8%af%86%e8%a1%a5%e5%85%85 aria-label=知识补充>知识补充</a><ul><li><a href=#%e6%b1%87%e7%bc%96%e6%8c%87%e4%bb%a4 aria-label=汇编指令>汇编指令</a></li></ul></li></ul></li><li><a href=#%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e8%ae%af%e6%9c%ba%e5%88%b6 aria-label=进程间通讯机制>进程间通讯机制</a><ul><li><a href=#%e7%bb%83%e4%b9%a0%e9%a2%98-1 aria-label=练习题>练习题</a></li></ul></li><li><a href=#fork aria-label=Fork>Fork</a></li><li><a href=#%e5%86%99%e5%85%a5%e5%bc%82%e5%b8%b8%e7%9a%84%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b aria-label=写入异常的处理流程>写入异常的处理流程</a></li><li><a href=#thinking aria-label=Thinking>Thinking</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener('DOMContentLoaded',function(){checkTocPosition(),elements=document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]'),activeElement=elements[0];const e=encodeURI(activeElement.getAttribute('id')).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add('active')},!1),window.addEventListener('resize',function(){checkTocPosition()},!1),window.addEventListener('scroll',()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute('id')).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add('active'):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove('active')})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue('--gap'),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=实验目的>实验目的<a hidden class=anchor aria-hidden=true href=#实验目的>#</a></h2><ol><li>掌握系统调用的概念及流程</li><li>实现进程间通讯机制</li><li>实现 fork 函数</li><li>掌握页写入异常的处理流程</li></ol><h2 id=系统和调用>系统和调用<a hidden class=anchor aria-hidden=true href=#系统和调用>#</a></h2><p>系统调用的概念：</p><p>在用户态下，用户进程不能访问系统的内核空间，也就是说它不能存取内核使用的内存数据，也不能调用内核函数， 这一点是由CPU的硬件结构保证的。然而，用户进程在特定的场景下往往需要执行一些只能由内核完成的操作，如 操作硬件、动态分配内存，以及与其他进程进行通信等。允许在内核态执行用户程序提供的代码显然是不安全的，因此操作系统设计了一系列内核空间 中的函数，==当用户进程需要进行这些操作时，会引发特定的异常以陷入内核态，由内核调用对应的函数==，从而安全地为用户进程提供受限的系统级操作， 我们把这种机制称为<strong>系统调用</strong>。</p><p>在 lab4 中，我们需要实现上述的系统调用机制，并在此基础上实现<strong>进程间通信</strong>（IPC）机制和一个重要的进程创建机制 <strong>fork</strong>。 在fork部分的实验中，我们会介绍一种被称为<strong>写时复制</strong>（COW）的特性，以及与其相关的<strong>页写入异常处理</strong>。</p><ol><li><p><strong>用户态和内核态</strong>（也称用户模式和内核模式）：</p><p>它们是 CPU 运行的两种状态。根据 lab3 的说明，在 MOS 操作系统实验使用的仿真 R3000 CPU 中，该状态由 CP0 SR 寄存器中 KUc 位的值标志。</p></li><li><p><strong>用户空间和内核空间</strong></p><p>它们是虚拟内存（进程的地址空间）中的两部分区域。根据 lab2 的说明，MOS 中的用户空间包括 kuseg， 而内核空间主要包括 kseg0 和 kseg1。每个进程的用户空间通常通过页表映射到不同的物理页，而内核空间则直接映射到固定的物理页<a href="https://os.buaa.edu.cn/courses/course-v1:BUAA+B3I062270+2022_SPRING/courseware/e470f921cff34e418655f9480cabce6c/c4329e6bc82b4cbdb60b83647c8c5f86/?child=first#fn1">1</a>以及外部硬件设备。 CPU 在内核态下可以访问任何内存区域，对物理内存等硬件设备有完整的控制权，而在用户态下则只能访问用户空间。</p></li><li><p><strong>（用户）进程和内核</strong></p><p>进程是资源分配与调度的基本单位，拥有独立的地址空间，而内核负责管理系统资源和调度进程，使进程能够并发运行。 与前两对概念不同，进程和内核并不是对立的存在，可以认为内核是存在于所有进程地址空间中的一段代码。</p></li></ol><p>设置*<code>env_tf.cp0_status</code> 的值为 <code>0x1000100c</code>*</p><p>系统调用：于直接使用这些系统调用较为麻烦，于是产生了一系列用户空间的API定义，如POSIX 和C标准库等，它们在系统调用的基础上， 实现更多更高级的常用功能，使得用户在编写程序时不用再处理这些繁琐而复杂的底层操作， 而是直接通过调用高层次的API就能实现各种功能。通过这样巧妙的层次划分，使得程序更为灵活，也具有了更好的可移植性。 对于用户程序来说，只要自己所依赖的API不变，无论底层的系统调用如何变化，都不会对自己造成影响， 更易于在不同的系统间移植。整个结构如下表所示。</p><p><img loading=lazy src=../%e6%96%87%e6%a1%a3.assets/image-20220516175009598.png alt=image-20220516175009598></p><p><strong>系统调用机制的实现</strong>：</p><p><img loading=lazy src=../%e6%96%87%e6%a1%a3.assets/4_syscall_process.png alt=syscall过程流程图></p><p><code>syscall_*</code>的函数的实现中，它们毫无例外都调用了msyscall函数，而且函数的第一个参数都是一个与调用名相似的宏（如<code>SYS_putchar</code>）， 在我们的MOS操作系统实验中把这个参数称为<strong>系统调用号</strong>（请在代码中找到这个宏的定义位置，了解系统调用号的排布规则）：</p><ul><li><strong>系统调用号查看</strong>：./include/unistd.h:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifndef UNISTD_H
</span></span></span><span class=line><span class=cl><span class=cp>#define UNISTD_H
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define __SYSCALL_BASE 9527
</span></span></span><span class=line><span class=cl><span class=cp>#define __NR_SYSCALLS 20
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define SYS_putchar 		((__SYSCALL_BASE ) + (0 ) ) 
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_getenvid 		((__SYSCALL_BASE ) + (1 ) )
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_yield			((__SYSCALL_BASE ) + (2 ) )
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_env_destroy		((__SYSCALL_BASE ) + (3 ) )
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_set_pgfault_handler	((__SYSCALL_BASE ) + (4 ) )
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_mem_alloc		((__SYSCALL_BASE ) + (5 ) )
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_mem_map			((__SYSCALL_BASE ) + (6 ) )
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_mem_unmap		((__SYSCALL_BASE ) + (7 ) )
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_env_alloc		((__SYSCALL_BASE ) + (8 ) )
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_set_env_status	((__SYSCALL_BASE ) + (9 ) )
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_set_trapframe		((__SYSCALL_BASE ) + (10 ) )
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_panic			((__SYSCALL_BASE ) + (11 ) )
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_ipc_can_send		((__SYSCALL_BASE ) + (12 ) )
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_ipc_recv		((__SYSCALL_BASE ) + (13 ) )
</span></span></span><span class=line><span class=cl><span class=cp>#define SYS_cgetc			((__SYSCALL_BASE ) + (14 ) )
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></td></tr></table></div></div><h3 id=练习题>练习题<a hidden class=anchor aria-hidden=true href=#练习题>#</a></h3><blockquote><p>由于网站中无法提交答案，因此在这里简记一下</p></blockquote><p>对于系统调用syscall_cgetc，它传入msyscall函数的系统调用号的数字值应该是： 9527+14 = 9541</p><p>阅读代码，如果想要增加一个系统调用，下面这些文件需要被修改：</p><ul><li>lib/syscall.S（系统调用列表sys_call_table）、include/unistd.h（系统调用号相关）、lib/syscall_all.c（内核态系统调用函数）、user/syscall_lib.c（用户态系统调用函数syscall_*()）</li></ul><p>在汇编宏CLI中，用到的STATUS_CU0的值是: 0x10000000(在<code>./include/asm/cp0regdef.h:41</code>处定义)</p><p>lib/syscall.S中最后一个TODO：/* TODO: 恢复栈指针到分配前的状态*/的正确代码是：<code>addiu sp, sp, 24</code></p><p>用于从异常中返回（恢复现场）的ret_from_exception宏的定义在这个文件中：<code>/lib/genex.S:32</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>FEXPORT(ret_from_exception)
</span></span><span class=line><span class=cl>	.set noat
</span></span><span class=line><span class=cl>	.set noreorder
</span></span><span class=line><span class=cl>	RESTORE_SOME		/* 定义于./include/stackframe.h:90 */
</span></span><span class=line><span class=cl>	.set at
</span></span><span class=line><span class=cl>	lw	k0,TF_EPC(sp)	/* 取出用户态当前地址 */
</span></span><span class=line><span class=cl>	lw	sp,TF_REG29(sp) /* Deallocate stack */  
</span></span><span class=line><span class=cl>//1:	j	1b
</span></span><span class=line><span class=cl>	nop
</span></span><span class=line><span class=cl>	jr	k0								 
</span></span><span class=line><span class=cl>	rfe		
</span></span></code></pre></td></tr></table></div></div><p>lib/syscall_all.c 中实现了一些系统调用，其中用于创建一个进程的是:<code>sys_env_alloc</code></p><h3 id=知识补充>知识补充<a hidden class=anchor aria-hidden=true href=#知识补充>#</a></h3><h4 id=汇编指令>汇编指令<a hidden class=anchor aria-hidden=true href=#汇编指令>#</a></h4><table><thead><tr><th>汇编码</th><th>含义</th></tr></thead><tbody><tr><td><code>mfc0 t, cs</code></td><td>把32位数据从协处理寄存器cs传送到通用寄存器t</td></tr><tr><td><code>mtc0 s, cs</code></td><td>把32位数据从通用寄存器s传送到协处理寄存器cs</td></tr><tr><td></td><td></td></tr></tbody></table><p>回顾指令</p><table><thead><tr><th>汇编码</th><th>含义</th></tr></thead><tbody><tr><td><code>sll d, s, shf</code></td><td><code>d = s &lt;&lt; shf</code></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id=进程间通讯机制>进程间通讯机制<a hidden class=anchor aria-hidden=true href=#进程间通讯机制>#</a></h2><table><thead><tr><th style=text-align:center>字段</th><th>含义</th></tr></thead><tbody><tr><td style=text-align:center>env_ipc_value</td><td>进程传递的具体数值</td></tr><tr><td style=text-align:center>env_ipc_from</td><td>发送方的进程ID</td></tr><tr><td style=text-align:center>env_ipc_recving</td><td>1：等待接受数据中；0：不可接受数据</td></tr><tr><td style=text-align:center>env_ipc_dstva</td><td>接收到的页面需要与自身的哪个虚拟页面完成映射</td></tr><tr><td style=text-align:center>env_ipc_perm</td><td>传递的页面的权限位设置</td></tr></tbody></table><img src=../文档.assets/4-ipc.png alt=IPC流程图 style=zoom:80%><h3 id=练习题-1>练习题<a hidden class=anchor aria-hidden=true href=#练习题-1>#</a></h3><blockquote><p>由于网站中无法提交答案，因此在这里简记一下</p></blockquote><p>进程控制块中用于表示进程是否处于接收状态的域是env_ipc_recving，（例如，env_ipc_value）如果处于接受状态，这个域的值是1</p><p>系统调用sys_ipc_recv中放弃CPU时，需要调用相关函数重新进行调度，请问这个相关函数是<code>sys_yield</code></p><h2 id=fork>Fork<a hidden class=anchor aria-hidden=true href=#fork>#</a></h2><h2 id=写入异常的处理流程>写入异常的处理流程<a hidden class=anchor aria-hidden=true href=#写入异常的处理流程>#</a></h2><h2 id=thinking>Thinking<a hidden class=anchor aria-hidden=true href=#thinking>#</a></h2><p><strong>Thinking 4.1</strong>. 思考并回答下面的问题：</p><ul><li>内核在保存现场的时候是如何避免破坏通用寄存器的？</li></ul><p>使用SAVE_ALL函数用于保存所有寄存器、使用CLI函数用于屏蔽中断位的设置</p><ul><li>系统陷入内核调用后可以直接从当时的$a0-$a3参数寄存器中得到用户调用msyscall留下的信息吗？</li></ul><blockquote><p>需要注意的是，陷入内核态的操作并不是从一个函数跳转到了另一个函数，此处的指针 $sp 是内核空间的栈指针，系统从用户态切换到内核态后，内核首先需要将原用户进程的运行现场保存到内核空间（其保存的结构与结构体<strong>struct</strong> <strong>Trapframe</strong>等同，请寻找完成这部分功能的代码实现），栈指针指向这个结构体的起始位置，因此我们正是借助这个保存的结构体来获取用户态中传递过来的值（例如：用户态下 $a0 寄存器的值保存在了当前栈下的 TF_REG4(sp)处）。 ——lab4指导书</p></blockquote><p>正如指导书中所说，陷入内核态的操作并不是从一个函数跳转到了另一个函数，故不能简单的从参数寄存器中获得值。</p><ul><li>我们是怎么做到让sys开头的函数“认为”我们提供了和用户调用msyscall时同样的参数的？</li></ul><p>从具体实现上讲，我们将内核空间中用于传参的寄存器中的值设置为了与msyscall中相同的状态，且栈帧顶的24Byte空间也设置成了与msyscall中相同的状态。</p><ul><li>内核处理系统调用的过程对Trapframe做了哪些更改？这种修改对应的用户态的变化是？</li></ul><p>按照cause寄存器的BD字段更新了TF_EPC，对应用户态返回的指令地址的变化</p><p>为TF_REG2(sp) 赋值，对应用户态设置了函数的返回值</p><p><strong>Thinking 4.2</strong>. 思考下面的问题，并对这个问题谈谈你的理解： 请回顾 lib/env.c 文件中 <code>mkenvid()</code> 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现 与 <code>envid2env()</code> 函数的行为进行解释。</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://appletea233.github.io/myblog_hogo/tags/study/>study</a></li><li><a href=http://appletea233.github.io/myblog_hogo/tags/os/>os</a></li></ul><nav class=paginav><a class=next href=http://appletea233.github.io/myblog_hogo/posts/blog/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/><span class=title>Next Page »</span><br><span>MIPS汇编基础</span></a></nav></footer><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://cdn.jsdelivr.net/npm/twikoo@1.5.9/dist/twikoo.all.min.js></script>
<script>twikoo.init({envId:"https://twikoo-12c9q2x4o-1530457905-qqcom.vercel.app/",el:"#tcomment",lang:'zh-CN',path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><span>&copy; 2022 <a href=http://appletea233.github.io/myblog_hogo>Appletea's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement('button');e.classList.add('copy-code'),e.innerText='copy';function s(){e.innerText='copied!',setTimeout(()=>{e.innerText='copy'},2e3)}e.addEventListener('click',o=>{if('clipboard'in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand('copy'),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>